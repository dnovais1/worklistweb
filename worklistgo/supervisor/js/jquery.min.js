/ *! jQuery v2.1.1 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license * /
! function (a, b) {"object" == typeof module && "object" == typeof module.exports? module.exports = a.document? b (a,! 0): function (a) {if (! a .document) throw new Error ("jQuery requer uma janela com um documento"); return b (a)}: b (a)} (janela "indefinida"! = tipoof window ?, esta função (a, b) { var c = [], d = c.slice, e = c.concat, f = c.push, g = c.indexOf, h = {}, i = h.toString, j = h.hasOwnProperty, k = { }, l = a.document, m = "2.1.1", n = função (a, b) {return new n.fn.init (a, b)}, o = / ^ [\ s \ uFEFF \ xA0 ] + | [\ s \ uFEFF \ xA0] + $ / g, p = / ^ - ms - /, q = / - ([\ da-z]) / gi, r = função (a, b) {return b.toUpperCase ()}; n.fn = n.prototype = {jquery: m, constructor: n, selector: "", comprimento: 0, toArray: function () {return d.call (this)}, get: função (a) {return null! = a? 0> a? this [a + this.length]: this [a]: d.call (this)}, pushStack: function (a) {var b = n.merge (this.constructor (), a); return b.prevObject = this, b.context = this.context, b}, cada: função (a, b) {return n.each (this, a, b)}, map: function (a) {return this.pushStack (n .map (isto, função (b, c) {return a.call (b, c, b)}))}, slice: function () {return this.pushStack (d.apply (this, arguments))} primeiro: function () {return this.eq (0)}, last: function () {return this.eq (-1)}, eq: function (a) {var b = this.length, c = + a + ( 0> a? B: 0); retorna this.pushStack (c> = 0 && b> c? [This [c]]: [])}, final: function () {return this.prevObject || this.constructor (null )}, pressione: f, classificar: c.sort, splice: c.splice}, n.extend = n.fn.extend = function () {var a, b, c, d, e, f, g = argumentos [0] || {}, h = 1, i = arguments.length, j =! 1; for ("boolean" == typeof g && (j = g, g = argumentos [h] || {}, h ++) , "object" == typeof g || n.isFunction (g) || (g = {}), h === i && (g = this, h -); i> h; h ++) se (nulo! = (a = argumentos [h]) para (b em a) c = g [b], d = a [b], g! == d && (j &&d && (n.isPlainObject (d) || (e = n.isArray (d))? (e? (e =! 1, f = c && n.isArray (c)? c: []): f = c && n. isPlainObject (c)? c: {}, g [b] = n.extend (j, f, d)): void 0! == d && (g [b] = d)); return g}, n.extend ({expando: "jQuery" + (m + Math.random ()). substituir (/ \ D / g, ""), isReady:! 0, erro: função (a) {throw new Error (a)}, noop: function () {}, isFunction: function (a) {return "function" === n.type (a)}, isArray: Array.isArray, isWindow: função (a) {return null! = a && a == = a.window}, isNumeric: função (a) {return! n.isArray (a) && a-parseFloat (a)> = 0}, isPlainObject: função (a) {return "objeto"! == n.type ( a) || a.nodeType || n.isWindow (a) ?! 1: a.constructor &&! j.call (a.constructor.prototype, "isPrototypeOf") ?! 1:! 0}, isEmptyObject: função (a ) {var b; para (b em a) return! 1; return! 0}, digite: function (a) {return null == a? a + "": "objeto "== typeof a ||" função "== typeof a? h [i.call (a)] ||" objeto ": typeof a}, globalEval: função (a) {var b, c = eval; a = n.trim (a), a && (1 === a.indexOf ("use strict")? (b = l.createElement ("script"), b.text = a, l.head.appendChild (b) (por exemplo, b) {return a.nodeName && a.nodeName.toLowerCase () === b.toLowerCase ()}, cada: função (a, b, c) {var d, e = 0, f = a.length, g = s (a), se (c) {if (g) {for (; f; e; e ++) se (d = b.apply (a [e], c), d ===! 1) break} else for (e em a) se (d = b.apply (a [e], c), d ===! 1) break} else if (g) {for (; f> e; e ++) if (d = b .call (a [e], e, a [e]), d ===! 1) break} else for (e in a) if (d = b.call (a [e], e, a [e ]), d ===! 1) break; return a}, trim: function (a) {return null == a? "" :( a + ""). substituir (o, "")}, makeArray:função (a, b) {var c = b || []; return null! = a && (s (Object (a))? n.merge (c, "string" == typeof a? [a]: a) : f.call (c, a)), c}, inArray: função (a, b, c) {return null == b? -1: g.call (b, a, c)}, fundir: função ( a, b) {for (var c = + b.length, d = 0, e = a.length; c> d; d ++) a [e ++] = b [d]; return a.length = e, a} grep: function (a, b, c) {for (var d, e = [], f = 0, g = a.length, h =! c; g> f; f ++) d =! b (a [ f], f), d! == h && e.push (a [f]); return e}, map: function (a, b, c) {var d, f = 0, g = a.length, h = s (a), i = []; se (h) para (; g> f; f ++) d = b (a [f], f, c), null! = d && i.push (d); else for ( f em a) d = b (a [f], f, c), null! = d && i.push (d); return e.apply ([], i)}, guid: 1, proxy: função (a, b) {var c, e, f; retornar "string" == typeof b && (c = a [b], b = a, a = c), n.isFunction (a)? (e = d.call (argumentos , 2), f = function () {return a.apply (b || this, e.concat (d.call (argumentos))}, f.guid = a.guid = a.guid || n.guid ++ , f): void 0}, agora: Date.now, suporte:k}), n.each ("Boolean Number String Function Array Date RegExp Object Error" .split (""), função (a, b) {h ["[object" + b + "]"] = b.toLowerCase ( )}); função s (a) {var b = a.length, c = n.type (a); return "function" === c || n.isWindow (a) ?! 1: 1 === a.nodeType && b?! 0: "array" === c || 0 === b || "número" == typeof b && b> 0 && b-1 em a} var t = função (a) {var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "sizzle" + - new Date, v = a.document, w = 0, x = 0, y = gb (), z = gb (), A = gb (), B = função (a, b) {return a === b && (l =! 0), 0} C = "indefinido", D = 1 << 31, E = {}. HasOwnProperty, F = [], G = F.pop, H = F.push, I = F.push, J = F.slice, K = F.indexOf || function (a) {for (var b = 0, c = this.length; c> b; b ++) se (este [b] === a) retorna b; return-1}, L = "verificado | selecionado | assíncrono | autofoco | reprodução automática | controles | adiar | desativado | ocultos | ismap | loop | multiple | open | readonly | required | scoped ", M =" [\\ x20 \\ t \\ r \\ n \ \ f] ", N =" (?: \\\\. | [\\ w-] | [^ \\ x00 - \\ xa0]) + ", O = N.replace (" w "," w # "), P =" \\ ["+ M +" * ("+ N +") (?: "+ M +" * ([* ^ $ |! ~]? =) "+ M +" * (?: ' ((:: \\\\. | [^ \\\\ ']) *)' | \ "((?: \\\\. | [^ \\\\\"]) *) \ "| (+) + (+) + \\\\ ']) *)' | \ "((?: \\\\. | [^ \\\\\"]) *) \ ") | ((?: \\\\. | [ ^ \\\\ () [\\]] | "+ P +") *) |. *) \\) |) ", R = novo RegExp (" ^ "+ M +" + | ((?: ^ | [^ \\\\]) (?: \\\\.) *) "+ M +" + $ "," g "), S = novo RegExp (" ^ "+ M +" *, "+ M +" * "), T = novo RegExp (" ^ "+ M +" * ([> + ~] | "+ M + ")" + M + "*"), U = novo RegExp ("=" + M + "* ([^ \\] '\"] *?) "+ M +" * \\] "," g " ), V = novo RegExp (Q), W = novo RegExp ("^" + O + "$"), X = {ID: novo RegExp ("^ # (" + N + ")"), CLASSE: novo RegExp ( "^ \\. (" + N + ")"), TAG: novo RegExp ("^ (" + N.replace ("w", "w *") + ")"), ATTR: novo RegExp ("^ "+ P), PSEUDO: novo RegExp (" ^ "+ Q), CRIANÇA: novo RegExp (" ^ :( apenas | primeiro | último | nth | nth-last] - (child | of-type) (?: \ \ ("+ M +" * (mesmo | estranho | (([+ -] |) (\\ d *) n |) "+ M +" * (?: ([+ -] |) "+ M +" * ( \\ d +) |)) "+ M +" * \\) |) "," i "), bool: novo RegExp (" ^ (?: "+ L +") $ "," i "), needsContext: new RegExp ("^" + M + "* [> + ~] |: (even | odd | eq | gt | lt | nth | first | last) (?: \\ (" + M + "* ((?- \\ d)? \\ d *) "+ M +" * \\) |) (? = [^ -] | $) "," i ")}, Y = / ^ (?: input | select | botão textarea | $ / i, Z = / ^ h \ d $ / i, $ = / ^ [^ {] + \ {\ s * \ [nativo \ w /, _ = / ^ (?: # ([ \ w -] +] | ([w -] +)) $ /, ab = / [+ ~] /, bb = / '| \\ / g, cb = novo RegExp ( "\\\\" + M + "? | (" + M + ") |.)", "ig"), db = função (a, b, c) {var d = "0x" + b-65536; return d! == d || c? b: 0> d? String.fromCharCode (d + 65536): String.fromCharCode (d >> 10 | 55296,1023 & d | 56320)}; tente {I.apply (F = J.call (v.childNodes), v.childNodes), F [v.childNodes.length] .nodeType} catch (eb) {I = {apply: F.length ? function (a, b) {H.apply (a, J.call (b))}: function (a, b) {var c = a.length, d = 0; while (a [c ++] = b [ d ++]); a.length = c-1}}} função fb (a, b, d, e) {var f, h, j, k, l, o, r, s, w, x; se (( b? b.ownerDocumento || b: v)! == n && m (b), b = b || n, d = d || [] ,! a || "string"! = typeof a) return d; if (1! == (k = b.nodeType) && 9!== k) return []; if (p &&! e) {if (f = _. exec (a)) se (j = f [1]) {if (9 === k) {if (h = b .getElementById (j) ,! h ||! h.parentNode) retornar d; if (h.id === j) retornar d.push (h), d} else if (b.ownerDocument && (h = b.ownerDocument .getElementById (j)) && t (b, h) && h.id === j) retornar d.push (h), d} else {if (f [2]) retornar I.apply (d, b.getElementsByTagName ( a)), d; se ((j = f [3]) && c.getElementsByClassName && b.getElementsByClassName) devolva I.apply (d, b.getElementsByClassName (j)), d} if (c.qsa && (! q ||! q.test (a))) {if (s = r = u, w = b, x = 9 === k && a, 1 === k && "objeto"! == b.nodeName.toLowerCase ()) {o = g (a), (r = b.getAttribute ("id"))? s = r.replace (bb, "\\ $ &"): b.setAttribute ("id", s), s = "[ id = '"+ s +"'] ", l = o.length; enquanto (l -) o [l] = s + qb (o [l]); w = ab.test (a) && ob (b. parentNode) || b, x = o.join (",")} se (x) tente {return I.apply (d, w.querySelectorAll (x)), d} catch (y) {} finally {r || b.removeAttribute ("id")}}} return i ( a.replace (R, "$ 1"), b, d, e)} função gb () {var a = []; função b (c, e) {retorna a.push (c + "")> d.cacheLength && delete b [a.shift ()], b [c + ""] = e} retornar b} função hb (a) {retornar uma [u] =! 0, a} função ib (a) {var b = n.createElement ("div"); tente {return !! a (b)} catch (c) {return! 1} finalmente {b.parentNode && b.parentNode.removeChild (b), b = null}} função jb (a, b) {var c = a.split ("|"), e = a.length; while (e -) d.attrHandle [c [e]] = b} função kb (a, b) {var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && (~ b.sourceIndex || D) - (~ a.sourceIndex || D); se (d) retornar d; if (c) while (c = c.nextSibling) se (c === b) return-1; retornar uma função? 1: -1} lb (a) {função de retorno (b) {var c = b.nodeName.toLowerCase ();retornar "input" === c && b.type === a}} função mb (a) {função de retorno (b) {var c = b.nodeName.toLowerCase (); return ("input" === c || "botão" === c) && b.type === a}} função nb (a) {return hb (função (b) {return b = + b, hb (função (c, d) {var e, f = a ([], c.length, b), g = f.length; while (g -) c [e = f [g]] && (c [e] =! (d [e] = c [ e]))})})} function ob (a) {return a && typeof a.getElementsByTagName! == C && a} c = fb.support = {}, f = fb.isXML = função (a) {var b = a && ( a.ownerDocument || a) .documentElement; return b? "HTML"! == b.nodeName:! 1}, m = fb.setDocument = função (a) {var b, e = a? a.ownerDocument || a: v, g = e.defaultView; return e! == n && 9 === e.nodeType && e.documentElement? (n = e, o = e.documentElement, p =! f (e), g && g! == g. top && (g.addEventListener? g.addEventListener ("descarregar", function () {m ()} ,! 1): g.attachEvent && g.attachEvent ("onunload", função () {m ()})), c.attributes = ib (função (a) {return a.className = "i",! a.getAttribute ("className")}) , c.getElementsByTagName = ib (função (a) {retorna a.appendChild (e.createComment ("")), a.getElementsByTagName ("*"). length}), c.getElementsByClassName = $. test (e. getElementsByClassName) && ib (função (a) {retorna a.innerHTML = "<div class = 'a'> </ div> <div class = 'a i'> </ div>", a.firstChild.className = "i ", 2 === a.getElementsByClassName (" i "). Length}), c.getById = ib (função (a) {return o.appendChild (a) .id = u,! E.getElementsByName ||! E .getElementsByName (u) .length}), c.getById? (d.find.ID = função (a, b) {if (typeof b.getElementById! == C && p) {var c = b.getElementById (a); retornar c && c.parentNode? [c]: []}}, d.filter.ID = função (a) {var b = a.replace (cb, db); função de retorno (a) {return a.getAttribute ("id") === b}}) :( delete d.find.ID, d.filter.ID = função (a) {var b = a.replace (cb, db); função de retorno (a) {var c = typeof a.getAttributeNode! == C && a.getAttributeNode ("id"); return c && c .value === b}}), d.find.TAG = c.getElementsByTagName? função (a, b) {return typeof b.getElementsByTagName! == C? b.getElementsByTagName (a): void 0}: function ( a, b) {var c, d = [], e = 0, f = b.getElementsByTagName (a); se ("*" === a) {while (c = f [e ++]) 1 === c.nodeType && d.push (c); return d} return f}, d.find.CLASS = c.getElementsByClassName && função (a, b) {return typeof b.getElementsByClassName! == C && p? b.getElementsByClassName (a): void 0 }, r = [], q = [], (c.qsa = $. test (e.querySelectorAll)) && (ib (function (a) {a.innerHTML = "<select msallowclip = ''> <opção selecionada = ''> </ option> </ select> ", a.querySelectorAll (" [msallowclip ^ = ''] "). length && q.push (" [* ^ $] = "+ M +" * (?: '' | \ "\") "), a.querySelectorAll (" [selected] "). length || q.push (" \\ ["+ M +" * (?: valor | "+ L +") ") , a.querySelectorAll (": checked"). length || q.push (": checked")}), ib (função (a) {var b = e.createElement ("input"); b.setAttribute (" tipo "," oculto "), a.appendChild (b) .setAttribute (" nome "," D "), a.querySelectorAll (" [nome = d] "). comprimento && q.push (" nome "+ M +" * [* ^ $ |! ~]? = "), a.querySelectorAll (": enabled "). length || q.push (": enabled ",": disabled "), a.querySelectorAll (" *,: x "), q.push (",. *: ")})), (c.matchSelector = $. test (s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ib (função (a) {c.disconnectedMatch = s.call (a, "div"), s.call (a, "[s! = '']: x"), r.push ("! =", Q)}), q = q.length && new RegExp (q.join (" | ")), r = r.length && new RegExp (r.join (" | ")), b = $ test (o.compareDocumentPosition), t = b || $ .test (o.contains)? function (a , b) {var c = 9 === a.nodeType? a.documentElement: a, d = b && b.parentNode; return a === d ||! (! d || 1! == d.nodeType || (c.contains? c.contains (d): a.compareDocumentPosition && 16 & a.compareDocumentPosition (d)))}: function (a, b) {if (b) while (b = b.parentNode) if (b === a) return! 0; return! 1}, B = b? função (a, b) {if (a === b) retorna l =! 0,0; var d =! a.compareDocumentPosition-! b.compareDocumentPosition ; return d? d: (d = (a.ownerDocument || a) === (b.ownerDocument || b)? a.compareDocumentPosition (b): 1,1 & d ||! c.sortDetached && b.compareDocumentPosition (a) === d? a === e || a.ownerDocument === v && t (v, a )? - 1: b === e || b.ownerDocument === v && t (v, b)? 1: k? K.call (k, a) -K.call (k, b): 0: 4 & d ? -1: 1)}: função (a, b) {if (a === b) return l =! 0,0; var c, d = 0, f = a.parentNode, g = b.parentNode, h = [a], i = [b]; se (! f ||! g) retornar a === e? -1: b === e? 1: f? -1: g? 1: k? K.call (k, a) -K.call (k, b): 0; se (f === g) retornar kb (a, b); c = a; while (c = c.parentNode) h. Desligue (c); c = b; enquanto (c = c.parentNode) i.unshift (c); enquanto (h [d] === i [d]) d ++; retorna d? kb (h [d], i [d]): h [d] === v? -1: i [d] === v? 1: 0}, e): n}, fb.matches = função (a, b) {return fb (a, null, null, b)}, fb.matchesSelector = função (a, b) {if ((a.ownerDocument || a)! == n && m (a), b = b.replace (U, " = '$ 1'] "),! (! C.matchesSelector ||! P || r && r.test (b) || q && q.test (b))) tente {var d = s.call (a, b); se (d || c.DisconnectedMatch || a.document && 11! == a.document.nodeType) return d} catch (e) {} return fb (b, n, null, [a]). length> 0}, fb.contains = function (a , b) {return (a.ownerDocument || a)! == n && m (a), t (a, b)}, fb.attr = função (a, b) {(a.ownerDocument || a)! = = n && m (a); var e = d.attrHandle [b.toLowerCase ()], f = e && E.call (d.attrHandle, b.toLowerCase ())? e (a, b,! p): void 0; retornar vazio 0! == f? f: c.attributes ||! p? a.getAttribute (b) :( f = a.getAttributeNode (b)) && f.specified? f.value: null}, fb.error = função (a) {throw new Error ("Erro de sintaxe, expressão não reconhecida:" + a)}, fb.uniqueSort = função (a) {var b, d = [], e = 0, f = 0; se (l =! c.detectDuplicates, k =! c.sortStable && a.slice (0), a.sort (B), l) {while (b = a [f ++]) b === a [f] && (e = d .push (f)), enquanto (e -) a.splice (d [e], 1)} retorna k = null, a}, e = fb.getText = function (a) {var b, c = " ", d = 0, f = a.nodeType;se (f = {if (1 === f || 9 === f || 11 === f) {if ("string" == typeof a.textContent) retorna a.textContent; para (a = a .firstChild; a; a = a.nextSibling) c + = e (a)} else if (3 === f || 4 === f) retorna a.nodeValue} else while (b = a [d ++]) c + = e (b); return c}, d = fb.selectors = {cacheLength: 50, createPseudo: hb, match: X, attrHandle: {}, find: {}, relative: {">": {dir: " parentNode ", primeiro:! 0}," ": {dir:" parentNode "}," + ": {dir:" previousSibling ", primeiro:! 0}," ~ ": {dir:" previousSibling "}}, PreFilter: {ATTR: função (a) {retorna um [1] = a [1] .replace (cb, db), a [3] = (a [3] || a [4] || a [5] || ""). replace (cb, db), "~ =" === a [2] && (a [3] = "" + a [3] + ""), a.slice (0,4 )}, CHILD: function (a) {return a [1] = a [1] .toLowerCase (), "nth" === a [1] .slice (0,3)? (A [3] || fb.error (a [0]), a [4] = + (a [4]? a [5] + (a [6] || 1): 2 * ("even"=== a [3] || "odd" === a [3])), a [5] = + (a [7] + a [8] || "odd" === a [3] )): a [3] && fb.error (a [0]), a}, PSEUDO: função (a) {var b, c =! a [6] && a [2]; retorna X.CHILD.test (a [0])? Null: (a [3]? A [2] = a [4] || a [5] || "": c && V.test (c) && (b = g (c,! 0) ) && (b = c.indexOf (")", c.length-b) -c.length) && (a [0] = a [0] .slice (0, b), a [2] = c. fatia (0, b)), a.slice (0,3))}}, filtro: {TAG: function (a) {var b = a.replace (cb, db) .toLowerCase (); return "*" === a? function () {return! 0}: function (a) {return a.nodeName && a.nodeName.toLowerCase () === b}}, CLASS: função (a) {var b = y [a + " "]; return b || (b = novo RegExp (" (^ | "+ M +") "+ a +" ("+ M +" | $) ")) && y (a, function (a) {return b.test ("string" == typeof a.className && a.className || typeof a.getAttribute! == C && a.getAttribute ("classe ") ||" ")})}, ATTR: função (a, b, c) {função de retorno (d) {var e = fb.attr (d, a); return null == e?"! = "=== b: b? (e + =" "," = "=== b? e === c:"! = "=== b? e! == c:" ^ = "=== b? c && 0 === e.indexOf (c): "* =" === b? c && e.indexOf (c)> - 1: "$ =" === b? c && e.slice (-c.length) === c: "~ =" === b? ("" + e + "") .indexOf (c)> - 1: "| =" === b? e === c || e.slice (0, c.length + 1) === c + "-" :! 1:) 0}}, CRIANÇA: função (a, b, c, d, e) {var f = "nth"! == a.slice (0,3), g = "last"! == a.slice (-4), h = "of-type" === b; return 1 === d && 0 === e? função ( a) {return !! a.parentNode}: função (b, c, i) {var j, k, l, m, n, o, p = f! == g? "nextSibling": "previousSibling", q = b.parentNode, r = h && b.nodeName.toLowerCase (), s =! i &&! h; se (q) {if (f) {while (p) {l = b;enquanto (l = l [p]) se (h? l.nodeName.toLowerCase () === r: 1 === l.nodeType) return! 1; o = p = "only" === a &&! o && "nextSibling"} return! 0} if (o = [g? q.firstChild: q.lastChild], g && s) {k = q [u] || (q [u] = {}), j = k [a ] || [], n = j [0] === w && j [1], m = j [0] === w && j [2], l = n && q.childNodes [n]; while (l = ++ n && l && l [p] || (m = n = 0) || o.pop ()) se (1 === l.nodeType && ++ m && l === b) {k [a] = [w, n, m] ; break}} else if (s && (j = (b [u] || (b [u] = {})) [a]) && j [0] === w) m = j [1]; (l = ++ n && l && l [p] || (m = n = 0) || o.pop ()) se ((h? l.nodeName.toLowerCase () === r: 1 === l.nodeType ) && ++ m && (s && ((l [u] || (l [u] = {})) [a] = [w, m]), l === b)) break; return m- = e m === d || m% d === 0 && m / d> = 0}}}, PSEUDO: função (a, b) {var c, e = d.pseudos [a] || d.setFilters [ a.toLowerCase ()] || fb.error ("pseudo não suportado:" + a);retornar e [u]? e (b): e.length> 1? (c = [a, a, "", b], d.setFilters.hasOwnProperty (a.toLowerCase ())? hb (função (a, c) {var d, f = e (a, b), g = f.length; enquanto (g -) d = K.call (a, f [g]), a [d] =! (c [ d] = f [g])}): função (a) {return e (a, 0, c)}): e}}, pseudos: {not: hb (function (a) {var b = [] c = [], d = h (a.replace (R, "$ 1")); return d [u]? hb (função (a, b, c, e) {var f, g = d (a, null e, []), h = a.length; while (h -) (f = g [h]) && (a [h] =! (b [h] = f))}): função (a e, f) {return b [0] = a, d (b, null, f, c) ,! c) (c) ()}}) tem: hb (função (a) {função de retorno (b) { retornar fb (a, b) .length> 0}}), contém: hb (função (a) {função de retorno (b) {return (b.textContent || b.innerText || e (b)). indexOf ( a)> - 1}}), lang: hb (função (a) {return W.test (a || "") || fb.error ("linguagem não suportada:" + a), a = a.replace ( cb, db) .toLowerCase (), função (b) {var c; faça se (c = p? b.lang: b.getAttribute ("xml: lang") || b.getAttribute ("lang")) return c = c.toLowerCase (), c === a || 0 === c.indexOf (a + "-"), enquanto que ((b = b.parentNode) && 1 === b.nodeType); return! 1}}), target: function (b) {var c = a.location && a.location.hash; return c && c.slice (1) === b.id}, raiz: função (a ) {return a === o}, foco: function (a) {return a === n.activeElement && (! n.hasFocus || n.hasFocus ()) && !! (a.type || a.href || ~ a.tabIndex)}, habilitado: function (a) {return a.disabled ===! 1}, desativado: function (a) {return a.disabled ===! 0}, checked: function (a ) {var b = a.nodeName.toLowerCase (); retornar "input" === b && !! a.checked || "opção" === b && !! a.selected}, selecionado: function (a) {return a.parentNode && a.parentNode.selectedIndex, a.selected ===! 0}, vazio: function (a) {for (a = a.firstChild; a; a = a.nextSibling) se (a.nodeType <6) retornarem ! 1; return! 0}, pai: função (a) {return! D.pseudos.empty (a)}, cabeçalho: função (a) {return Z.test (a.nodeName)}, entrada: function (a) {return Y.test (a.nodeName)}, botão: function (a) {var b = a.nodeName.toLowerCase (); retornar "input" === b && "botão" === a.type || "botão" === b}, texto: função (a) {var b; retornar "input" === a.nodeName.toLowerCase () && "text" === a.type && (null == (b = a.getAttribute ("tipo")) || "text" === b. toLowerCase ())}, primeiro: nb (function () {return [0]}), last: nb (function (a, b) {return [b-1]}), eq: nb (function (a, b , c) {return [0> c? c + b: c]}), mesmo: nb (function (a, b) {for (var c = 0; b> c; c + = 2) a.push (c ); return a}), odd: nb (função (a, b) {para (var c = 1; b> c; c + = 2) a.push (c); return a}), lt: nb (função (a, b, c) {para (var d = 0> c? c + b: c; - d> = 0;) a.push (d); return a}), gt: nb (função (a , b, c) {for (var d = 0> c? c + b: c; ++ d <b;) a.push (d); return a})}}, d.pseudos.nth = d.pseudos.eq; para (b em {radio:! 0, caixa de seleção:! 0, arquivo:! 0, senha:! 0, imagem:! 0}) d.pseudos [b] = lb (b) ; para (b em {submit:! 0, reset:! 0}) d.pseudos [b] = mb (b); function pb () {} pb.prototype = d.filters = d.pseudos, d.setFilters = novo pb, g = fb.tokenize = função (a, b) {var c, e, f, g, h, i, j, k = z [a + ""]; se (k) retornar b? 0: k.slice (0); h = a, i = [], j = d.preFilter; enquanto (h) {(! c || (e = S.exec (h))) && (e && (h = h .slice (e [0] .length) || h), i.push (f = [])), c =! 1, (e = T.exec (h)) && (c = e.shift () , f.push ({valor: c, tipo: e [0] .replace (R, "")}), h = h.slice (c.length)); para (g in d.filter)! (e = X [g] .exec (h)) || j [g] &&! (E = j [g] (e)) || (c = e.shift (), f.push ({valor: c, digite: g, combina: e}), h = h.slice (c.length)); se (! c) break} retornar b? h.length: h? fb.error (a): z (a, i ) .slice (0)}; função qb (a) {for (var b = 0, c = a.length, d = ""; c> b; b ++) d + = a [b] .value; return d} função rb (a, b, c) {var d = b.dir, e = c && "parentNode" === d, f = x ++; retornar b.first? função (b, c, f) {while (b = b [d]) se (1 === b.nodeType || e) return uma (b, c, f)}: função (b, c, g) {var h, i, j = [w, f]; se (g) {while (b = b [d]) se ((1 === b.nodeType || e) && a (b, c, g)) return! 0} else while (b = b [d]) se (1 === b.nodeType || e) {if (i = b [u] || (b [u] = {}), (h = i [d]) && h [0] === w && h [1] === f) retornar j [2] = h [2 ], se (i [d] = j, j [2] = a (b, c, g)) return! 0}}} função sb (a) {return a.length> 1? function (b, c, d) {var e = a.length; while (e -) se (! a [e] (b, c, d)) retornar! 1; return! 0}: a [0]} função tb (a, b c) {para (var d = 0, e = b.length; e> d; d ++) fb (a, b [d], c); retorno c} função ub (a, b, c, d, e) {for (var f, g = [], h = 0, i = a.length, j = null! = b; i> h; h ++) (f = a [h]) && (! c || c (f, d, e)) && (g.push (f), j && b.push (h)); return g} função vb (a, b, c, d, e, f) {return d &&! d [ u] && (d = vb (d)), e &&! e [u] && (e = vb (e, f)), hb (função (f, g, h,i) {var j, k, l, m = [], n = [], o = g.length, p = f || tb (b || "*", h.nodeType? [h]: h, []), q =! a ||! f && b? p: ub (p, m, a, h, i), r = c? e || (f? a: o || d)? []: g : q; if (c && c (q, r, h, i), d) {j = ub (r, n), d (j, [], h, i), k = j.length; while (k- - () [q [n [k]] = (q [n [k]] = l))} if (f) {if (e || a) {if (e ) {j = [], k = r.length; enquanto (k -) (l = r [k]) && j.push (q [k] = l); e (null, r = [], j, i)} k = r.length; enquanto (k -) (l = r [k]) && (j = e? K.call (f, l): m [k])> - 1 && (f [j ] =! (g [j] = l))}} else r = ub (r === g? r.splice (o, r.length): r), e? e (null, g, r, i ): I.apply (g, r)})} função wb (a) {para (var b, c, e, f = a.length, g = d.relative [a [0] .type], h = g || d.relative [""], i = g? 1: 0, k = rb (função (a) {return a === b}, h,! 0), l = rb (função (a) {return K.call (b, a)> - 1}, h,! 0), m = [função (a, c, d) {return! g && (d || c! == j) || (( b = c) .nodeType? k (a, c, d): l (a, c, d))}]; f> i; i ++) se (c = d.relative [a [i] .type]) m = [rb (sb (m), c)]; else {if (c = d.filtro [a [i] .type] .apply (null, a [i] .matches), c [u]) {for (e = ++ i; f> e; e ++) se (d.relative [a [ e] .type]) break; return vb (i> 1 && sb (m), i> 1 && qb (a.slice (0, i-1) .concat ({valor: "" === a [i-2]. digite? "*": ""})). replace (R, "$ 1"), c, e> i && wb (a.slice (i, e)), f> e && wb (a = a.slice (e)) , f> e && qb (a))} m.push (c)} return sb (m)} função xb (a, b) {var c = b.length> 0, e = a.length> 0, f = função (f, g, h, i, k) {var l, m, o, p = 0, q = "0", r = f && [], s = [], t = j, u = f || e && d .find.TAG ("*", k), v = w + = null == t? 1: Math.random () || .1, x = u.length; para (k && (j = g! == n && g ); q! == x && null! = (l = u [q]); q ++) {if (e && l) {m = 0; enquanto (o = a [m ++]) se (o (l, g, h)) {i.push (l); break} k && (w = v)} c && ((l =! o && l) && p -, f && r.push (l))} se (p + = q, c && q! == p) { m = 0;enquanto (o = b [m ++]) o (r, s, g, h); se (f) {if (p> 0) enquanto (q -) r [q] || s [q] || ( s [q] = G.call (i)); s = ub (s)} I.apply (i, s), k &&! f && s.length> 0 && p + b.length> 1 && fb.uniqueSort (i)} return k && (w = v, j = t), r}; retornar c? hb (f): f} retornar h = fb.compile = função (a, b) {var c, d = [], e = [] f = A [a + ""]; se (! f) {b || (b = g (a)), c = b.length; enquanto (c -) f = wb (b [c]), f [u]? d.push (f): e.push (f); f = A (a, xb (e, d)), f.selector = a} return f}, i = fb.select = function ( a, b, e, f) {var i, j, k, l, m, n = "function" == typeof a && a, o =! f && g (a = n.selector || a); if (e = e || [], 1 === o.length) {if (j = o [0] = o [0] .slice (0), j.length> 2 && "ID" === (k = j [0 ]). digite && c.getById && 9 === b.nodeType && p && d.relative [j [1] .type]) {if (b = (d.find.ID (k.matches [0] .replace (cb, db), b ) || []) [0] ,! b) return e; n && (b = b.parentNode), a = a.slice (j.shift (). Value.comprimento)} i = X.needsContext.test (a)? 0: j.length; while (i -) {if (k = j [i], d.relative [l = k.type]) break; if ((m = d.find [l]) && (f = m (k.matches [0] .replace (cb, db), ab.test (j [0] .type) && ob (b.parentNode) || b))) {if (j.splice (i, 1), a = f.length && qb (j), a) return I.apply (e, f), e; break}}} return (n || h (a, o)) (f, b,! p, e, ab.test (a) && ob (b.parentNode) || b), e}, c.sortStable = u.split (""). classificar ( B) .join ("") === u, c.detectDuplicates = !! l, m (), c.sortDetached = ib (função (a) {return 1 & a.compareDocumentPosition (n.createElement ("div")) }), ib (função (a) {retorna a.innerHTML = "<a href='#'> </a>", "#" === a.firstChild.getAttribute ("href")}) || jb ("digite | href | height | width", função (a, b, c) {return c? void 0: a.getAttribute (b, "type" === b.toLowerCase ()? 1: 2)} ), c.attributes &&ib (função (a) {retorna a.innerHTML = "<input />", a.firstChild.setAttribute ("valor", ""), "" === a.firstChild.getAttribute ("value")}) || jb ("valor", função (a, b, c) {retornar c || "entrada"! == a.nodeName.toLowerCase ()? void 0: a.defaultValue}), ib (função (a) {return null == a.getAttribute ("desativado")}) || jb (L, function (a, b, c) {var d; return c? void 0: a [b] ===! 0? b .toLowerCase () :( d = a.getAttributeNode (b)) && d.specified? d.value: null}), fb} (a); n.find = t, n.expr = t.selectors, n.expr [":"] = n.expr.pseudos, n.unique = t.uniqueSort, n.text = t.getText, n.isXMLDoc = t.isXML, n.contains = t.contains; var u = n.expr .match.needsContext, v = / ^ <(\ w +) \ s * \ /?> (?: <\ / \ 1> |) $ /, w = / ^. [^: # \ [\.,] * $ /; função x (a, b, c) {if (n.isFunction (b)) return n.grep (a, function (a, d) {return !! b.call (a, d, a) ! == c}), se (b.nodeType) return n.grep (a, function (a) {return a === b! == c}); if ("string" == typeof b) {if (w.test (b)) return n. filtro (b, a, c); b = n.filter (b, a)} return n.grep (a, função (a) {return g.call (b, a)> = 0! == c}) } n.filter = função (a, b, c) {var d = b [0]; return c && (a = ": not (" + a + ")"), 1 === b.length && 1 === d .nodeType? n.find.matchesSelector (d, a)? [d]: []: n.find.matches (a, n.grep (b, função (a) {return 1 === a.nodeType}) )}, n.fn.extend ({find: function (a) {var b, c = this.length, d = [], e = this; if ("string"! = typeof a) retorna this.pushStack ( n (a) .filter (function () {for (b = 0; c> b; b ++) se (n.contains (e [b], this)) return! 0})); para (b = 0; c> b; b ++) n.find (a, e [b], d); return d = this.pushStack (c> 1? n.unique (d): d), d.selector = this.selector? this .selector + "" + a: a, d}, filtro: função (a) {return this.pushStack (x (this, a || [] ,! 1))}, não: function (a) {return this.pushStack (x (this, a || [] ,! 0))}, é: function (a) {return !! x (this, "string" == typeof a && u.test (a)? n (a): a || [] ,! 1) .length}}); var y, z = / ^ (?: \ s * (<[\ w \ W] +>) [^>] * | # ([\ w -] *)) $ /, A = n.fn.init = função (a, b) {var c, d; se (! A) retornar isso; se ("string" == typeof a) {if (c = "<" === a [0] && ">" === a [a.length-1] && a.length> = 3? [null, a, null]: z.exec (a) ,! c ||! c [1] && b) return! b || b.jquery? (b || y) .find (a): this.constructor (b) .find (a); if (c [1]) { se (b = b instância de n? b [0]: b, n.merge (this, n.parseHTML (c [1], b && b.nodeType? b.ownerDocument || b: l,! 0)), v. teste (c [1]) && n.isPlainObject (b)) para (c in b) n.isFunction (this [c])? this [c] (b [c]): this.attr (c, b [c ]); return this} return d = l.getElementById (c [2]), d && d.parentNode && (this.length = 1, this [0] = d), this.context = l, this.selector = a, this } retorna a.nodeType? (isto.context = this [0] = a, this.length = 1, this): n.isFunction (a)? "undefined"! = typeof y.ready? y.ready (a): a (n) :( void 0 ! == a.selector && (this.selector = a.selector, this.context = a.context), n.makeArray (a, this))}; A.prototype = n.fn, y = n (l); var B = / ^ (?: parents | prev (?: Until | All)) /, C = {children:! 0, contents:! 0, next:! 0, prev:! 0}; n.extend ({ dir: function (a, b, c) {var d = [], e = void 0! == c; while ((a = a [b]) && 9! == a.nodeType) if (1 === a.nodeType) {if (e && n (a) .is (c)) break; d.push (a)} return d}, irmão: function (a, b) {for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a! == b && c.push (a); return c}}), n.fn.extend ({tem: function (a) {var b = n (a, this ), c = b.length; retorna this.filter (function () {for (var a = 0; c> a; a ++) se (n.contains (this, b [a])) return! 0})} mais próximo: function (a, b) {for (var c, d = 0, e = this.length, f = [], g = u.test (a) || "string"! = typeof a? n ( a, b || this.context): 0;e> d; d ++) para (c = this [d]; c && c! == b; c = c.parentNode) se (c.nodeType <11 && (g? g.index (c)> - 1: 1 == = c.nodeType && n.find.matchesSelector (c, a))) {f.push (c); break} retorna this.pushStack (f.length> 1? n.unique (f): f)}, índice: função (a) {return a? "string" == typeof a? g.call (n (a), this [0]): g.call (this, a.jquery? a [0]: a): this [ 0] && this [0] .parentNode? This.first (). PrevAll (). Length: -1}, add: function (a, b) {return this.pushStack (n.unique (n.merge (this.get (),}, addBack: function (a) {return this.add (null == a? this.prevObject: this.prevObject.filter (a))}}); função D (a, b) {while ((a = a [b]) && 1! == a.nodeType); return a} n.each ({parent: function (a) {var b = a.parentNode; return b && 11! == b.nodeType? b: null}, pais: função (a) {return n.dir (a, "parentNode")}, parentsUntil: function (a, b, c) {return n.dir (a, " parentNode ", c)},seguinte: função (a) {return D (a, "nextSibling")}, prev: function (a) {return D (a, "previousSibling")}, nextAll: função (a) {return n.dir (a, "nextSibling")}, prevAll: function (a) {return n.dir (a, "previousSibling")}, nextUntil: function (a, b, c) {return n.dir (a, "nextSibling", c) }, prevUntil: function (a, b, c) {return n.dir (a, "previousSibling", c)}, irmãos: function (a) {return n.sibling ((a.parentNode || {}). firstChild, a)}, children: function (a) {return n.sibling (a.firstChild)}, conteúdo: function (a) {return a.contentDocument || n.merge ([], a.childNodes)}} , função (a, b) {n.fn [a] = função (c, d) {var e = n.map (isto, b, c); retornar "Até"! == a.slice (-5) && (d = c), d && "string" == typeof d && (e = n.filter (d, e)), this.length> 1 && (C [a] || n.unique (e), B.test (a) && e.reverse ()), this.pushStack (e)}});var E = / \ S + / g, F = {}; função G (a) {var b = F [a] = {}; retornar n.each (a.match (E) || [], função (a c) {b [c] =! 0}), b} n.Callbacks = função (a) {a = "string" == typeof a? F [a] || G (a): n.extend ( {}, a); var b, c, d, e, f, g, h = [], i =! a.once && [], j = função (l) {para (b = a.memory && l, c = ! 0, g = e || 0, e = 0, f = h.length, d =! 0; h && f> g; g ++) se (h [g] .apply (l [0], l [1]) ===! 1 && a.stopOnFalse) {b =! 1; break} d =! 1, h && (i? I.length && j (i.shift ()): b? H = []: k.disable ())} k = {add: function () {if (h) {var c = h.length;! function g (b) {n.each (b, function (b, c) {var d = n.type (c ); "function" === d? a.unique && k.has (c) || ​​h.push (c): c && c.length && "string"! == d && g (c)})} (argumentos), d? f = h.length: b && (e = c, j (b))} return this}, remove: function () {return h && n.each (argumentos, função (a, b) {var c; while ((c = n .inArray (b, h, c))> - 1) h.splice (c, 1),d && (f> = c && f -, g> = c && g -)}), this} tem: function (a) {return a? n.inArray (a, h)> - 1:! (! h || !. h.length)}, empty: function () {return h = [], f = 0, this}, disable: function () {return h = i = b = void 0, this}, disabled: function () {return! h}, lock: function () {return i = void 0, b || k.disable (), this}, locked: function () {return! i}, fireWith: função (a, b) { retornar! h || c &&! i || (b = b || [], b = [a, b.slice? b.slice (): b], d? i.push (b): j (b) ), this}, fire: function () {return k.fireWith (this, arguments), this}, disparado: function () {return !! c}}; return k}, n.extend ({Diferido: função ( a) {var b = [["resolve", "done", n.Callbacks ("once memory"), "resolved"], ["rejeitar", "fail", n.Callbacks ("uma vez que a memória"), "rejeitado"], ["notificar", "progresso", n.Callbacks ("memória")]], c = "pendente",d = {state: function () {return c}, sempre: function () {return e.done (arguments) .fail (arguments), this}, then: function () {var a = arguments; return n.Deferred (função (c) {n.each (b, função (b, f) {var g = n.isFunction (a [b]) && a [b]; e [f [1]] (function () {var a = g && g.apply (isto, argumentos); a && n.isFunction (a.promise)? a.promise (). done (c.resolve) .fail (c.reject) .progress (c.notify): c [f [ 0] + "Com"] (isto === d? C.promise (): isto, g? [A]: argumentos)})}), a = null}). Promise ()}, promessa: function ( a) {return null! = a? n.extend (a, d): d}}, e = {}; return d.pipe = d.then, n.each (b, function (a, f) {var g = f [2], h = f [3]; d [f [1]] = g.add, h && g.add (function () {c = h}, b [1 ^ a] [2] .disable , b [2] [2] .lock), e [f [0]] = function () {return e [f [0] + "With"] (this === e? d: this, arguments), isto}, e [f [0] + "Com"] = g.fireWith}), d.promise (e), a && a.call (e, e), e}, quando: function (a) {var b = 0, c = d.chamada (argumentos), e = c.length, f = 1! == e || a && n.isFunction (a.promise)? e: 0, g = 1 === f? a: n.Deferred (), h = função (a, b, c) {função de retorno (e) {b [a] = this, c [a] = arguments.length> 1? d.call (argumentos): e, c === i? g .notifyWith (b, c): - f || g.resolveWith (b, c)}}, i, j, k; if (e> 1) para (i = nova matriz (e), j = nova matriz (e), k = nova Array (e); e> b; b ++) c [b] && n.isFunction (c [b] .promise)? c [b] .promise (). done (h (b, k , c)). fail (g.reject) .progress (h (b, j, i)): - f; return f || g.resolveWith (k, c), g.promise ()}}); var H; n.fn.ready = função (a) {return n.ready.promise (). done (a), this}, n.extend ({isReady:! 1, readyWait: 1, holdReady: função (a ) {a? n.readyWait ++: n.ready (! 0)}, pronto: função (a) {(a ===! 0? - n.readyWait: n.isReady) || (n.isReady =! 0, a! ==! 0 && - n.readyWait> 0 || (H.resolveWith (l, [n]), n.fn.triggerHandler && (n (l) .triggerHandler ("pronto"), n (l ) .off ("pronto"))))}});função I () {l.removeEventListener ("DOMContentLoaded", I,! 1), a.removeEventListener ("load", I,! 1), n.ready ()} n.ready.promise = function (b) { retornar H || (H = n.Deferred (), "complete" === l.readyState? setTimeout (n.ready) :( l.addEventListener ("DOMContentLoaded", I,! 1), a.addEventListener (" carregar ", I,! 1))), H.promise (b)}, n.ready.promise (); var J = n.access = function (a, b, c, d, e, f, g) {var h = 0, i = a.length, j = null == c; if ("object" === n.type (c)) {e =! 0; para (h em c) n.accesso ( a, b, h, c [h], 0, f, g)} else if (void 0! == d && (e =! 0, n.isFunction (d) || (g =! 0), j && (g) (b.call (a, d), b = null) :( j = b, b = função (a, b, c) {return j.call (n (a), c)})), b)) para (; i> h; h ++) b (a [h], c, g? d: d.call (a [h], h, b (a [h], c))); return e ? a: j? b.call (a): i? b (a [0], c): f}; n.acceptData = função (a) {return 1 === a.nodeType || 9 === a.nodeType ||! + a.nodeType}; função K () {Object.defineProperty (this.cache = {}, 0, {get: function () {return {}}}), this.expando = n.expando + Math.random ()} K.uid = 1, K.accepts = n .acceptData, K.prototype = {key: function (a) {if (! K.accepts (a)) return 0; var b = {}, c = a [this.expando]; se (! c) {c = K.uid ++; tente {b [this.expando] = {valor: c}, Object.defineProperties (a, b)} catch (d) {b [this.expando] = c, n.extend (a, b )}} return this.cache [c] || (this.cache [c] = {}), c}, set: function (a, b, c) {var d, e = this.key (a), f = this.cache [e]; if ("string" == typeof b) f [b] = c; else if (n.isEmptyObject (f)) n.extend (this.cache [e], b); mais para (d em b) f [d] = b [d]; return f}, get: function (a, b) {var c = this.cache [this.key (a)]; return void 0 == = b? c: c [b]}, acesso: função (a, b, c) {var d; return void 0 === b || b && "string" == typeof b & e void 0 === c? (d = this.get (a, b), void 0! == d? d: this.get (a, n.camelCase (b))) :( this.set (a, b, c), void 0! = = c? c: b)}, remove: function (a, b) {var c, d, e,f = this.key (a), g = this.cache [f]; if (void 0 === b) this.cache [f] = {}; else {n.isArray (b)? d = b. concat (b.map (n.camelCase)) :( e = n.camelCase (b), b em g? d = [b, e] :( d = e, d = d em g? [d]: d .match (E) || []), c = d.length; while (c -) delete g [d [c]]}}, hasData: function (a) {return! n.isEmptyObject (this. cache [a [this.expando]] || {})}, descarte: function (a) {a [this.expando] && delete this.cache [a [this.expando]]}}; var L = new K, M = novo K, N = / ^ (?: \ {[\ W \ W] * \} | \ [[\ w \ W] * \]) $ /, O = / ([AZ]) / g; função P (a, b, c) {var d; if (void 0 === c && 1 === a.nodeType) se (d = "dados -" + b.replace (O, "- $ 1"). toLowerCase (), c = a.getAttribute (d), "string" == typeof c) {try {c = "true" === c?! 0: "false" === c?! 1: "null" === c? null: + c + "" === c? + c: N.test (c)? n.parseJSON (c): c} catch (e) {} M.set (a, b, c )} else c = void 0; return c} n.extend ({hasData: function (a) {return M.hasData (a) || L.hasData (a)}, dados: função (a, b, c) {return M.access (a, b, c)}, removeData: função (a, b) {M.remove (a, b)
}, _ data: function (a, b, c) {return L.access (a, b, c)}, _ removeData: função (a, b) {L.remove (a, b)}}), n.fn .extend ({data: function (a, b) {var c, d, e, f = this [0], g = f && f.attributes; if (void 0 === a) {if (this.length && (e = M.get (f), 1 === f.nodeType &&! L.get (f, "hasDataAttrs"))) {c = g.length; while (c -) g [c] && (d = g [c] .name, 0 === d.indexOf ("dados -") && (d = n.camelCase (d.slice (5)), P (f, d, e [d]))); L .set (f, "hasDataAttrs",! 0)} return e} return "objeto" == typeof a? this.each (function () {M.set (this, a)}): J (isto, função ( b) {var c, d = n.camelCase (a); if (f && void 0 === b) {if (c = M.get (f, a), void 0! == c) retornar c; se ( c = M.get (f, d), vazio 0! == c) retornar c; se (c = P (f, d, void 0), void 0! == c) retornar c} else this.each ( function () {var c = M.get (isto, d); M.set (isto, d, b), - 1! == a.indexOf ("-") && void 0! == c && M.set (isto , a, b)})}, null, b,arguments.length> 1, null,! 0)}, removeData: function (a) {return this.each (function () {M.remove (this, a)})}}), n.extend ({fila: função (a, b, c) {var d; return a? (b = (b || "fx") + "fila", d = L.get (a, b), c && (! d || n. isArray (c)? d = L.access (a, b, n.makeArray (c)): d.push (c)), d || []): void 0}, dequeue: function (a, b) {b = b || "fx"; var c = n.queue (a, b), d = c.length, e = c.shift (), f = n._queueHooks (a, b), g = função () {n.dequeue (a, b)}; "inprogress" === e && (e = c.shift (), d -), e && ("fx" === b && c.unshift ("inprogress") , delete f.stop, e.call (a, g, f)) ,! d && f && f.empty.fire ()}, _ queueHooks: function (a, b) {var c = b + "queueHooks"; retornar L.get ( a, c) || ​​L.access (a, c, {empty: n.Callbacks ("once memory"). add (function () {L.remove (a, [b + "queue", c])}) })}}), n.fn.extend ({fila: função (a, b) {var c = 2;retornar "string"! = typeof a && (b = a, a = "fx", c -), arguments.length <c? n.queue (this [0], a): void 0 === b? this : this.each (function () {var c = n.queue (this, a, b); n._queueHooks (isto, a), "fx" === a && "inprogress"! == c [0] && n .dequeue (isto, a)})}, dequeue: function (a) {return this.each (function () {n.dequeue (this, a)})}, clearQueue: function (a) {return this.queue (a || "fx", [])}, promessa: function (a, b) {var c, d = 1, e = n.Deferred (), f = this, g = this.length, h = function () {= d || e.resolveWith (f, [f])}; "string"! = typeof a && (b = a, a = void 0), a = a || "fx", enquanto (g -) c = L.get (f [g], a + "queueHooks"), c && c.empty && (d ++, c.empty.add (h)); return h (), e.promise (b)}}) ; var Q = / [+ -]? (?: \ d * \. |) \ d + (?: [eE] [+ -]? \ d + |) /. source, R = ["Top", "Direito "," Fundo "," Esquerda "], S = função (a,b) {return a = b || a, "none" === n.css (a, "display") ||! n.contains (a.ownerDocument, a)}, T = / ^ (?: caixa de seleção | radio) $ / i;! function () {var a = l.createDocumentFragment (), b = a.appendChild (l.createElement ("div")), c = l.createElement ("entrada"); c. setAttribute ("type", "radio"), c.setAttribute ("checked", "checked"), c.setAttribute ("name", "t"), b.appendChild (c), k.checkClone = b. cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, b.innerHTML = "<textarea> x </ textarea>", k.noCloneChecked = !! b.cloneNode (! 0) .lastChild.defaultValue} ( ); var U = "indefinido"; k.focusinBubbles = "onfocusin" em a; var V = / ^ key /, W = / ^ (?: mouse | pointer | contextmenu) | clique /, X = / ^ (? : focusinfocus | focusoutblur) $ /, Y = / ^ ([^.] *) (?: \. (. +) |) $ /; função Z () {return! 0} função $ () {return!1} função _ () {try {return l.activeElement} catch (a) {}} n.event = {global: {}, add: function (a, b, c, d, e) {var f, g (r) {c.handler && (f = c, c = f.handler, e = f), h, i, j, k, l, m, o, p, q, r = L.get (a); .selector), c.guid || (c.guid = n.guid ++), (i = r.events) || (i = r.events = {}), (g = r.handle) || (g = r.handle = função (b) {return typeof n! == U && n.event.triggered! == b.type? n.event.dispatch.apply (a, argumentos): void 0}), b = (b || ""). match (E) || [""], j = b.length; while (j -) h = Y.exec (b [j]) || [], o = q = h [1], p = (h [2] || ""). Split ("."). Sort (), o && (l = n.event.special [o] || {}, o = (e? l.delegateType: l.bindType) || o, l = n.event.special [o] || {}, k = n.extend ({type: o, origType: q, data: d, handler: c, guid: c.guid, selector: e, needsContext: e && n.expr.match.needsContext.test (e), namespace: p.join (".")}, f), (m = i [o]) || (m = i [o] = [], m.delegateCount = 0, l.setup && l.setup.chamada (a, d, p, g)! ==! 1 || a.addEventListener && a.addEventListener (o, g,! 1)), l.add && (l.add.call (a, k), k.handler .guid || (k.handler.guid = c.guid)), e? m.splice (m.delegateCount ++, 0, k): m.push (k), n.event.global [o] =! 0 )}}, remover: função (a, b, c, d, e) {var f, g, h, i, j, k, l, m, o, p, q, r = L.hasData (a) && L.get (a); if (r && (i = r.events)) {b = (b || ""). Match (E) || [""], j = b.length; while (j- -) se (h = Y.exec (b [j]) || [], o = q = h [1], p = (h [2] || ""). split ("."). classifique (), o) {l = n.event.special [o] || {}, o = (d? l.delegateType: l.bindType) || o, m = i [o] || [], h = h [2] && new RegExp ("(^ | \\.)" + p.join ("\\. (?:. * \\. |)") + "(\\. $)") g = f = m.length; while (f -) k = m [f] ,! e && q! == k.origType || c && c.guid! == k.guid || h &&! h.test (k. namespace) || d && d! == k.selector && ("**"! == d ||! k.selector) || (m.splice (f, 1),k.selector && m.delegateCount -, l.remove && l.remove.call (a, k)); g &&! m.length && (l.teardown && l.teardown.call (a, p, r.handle)! ==! 1 | | n.removeEvent (a, o, r.handle), delete i [o])} else para (o in i) n.event.remove (a, o + b [j], c, d,! 0) ; n.isEmptyObject (i) && (delete r.handle, L.remove (a, "events"))}}, trigger: function (b, c, d, e) {var f, g, h, i, k, m, o, p = [d || l], q = j.call (b, "type")? b.type: b, r = j.call (b, "namespace")? b.namespace .split ("."): []; if (g = h = d = d || l, 3! == d.nodeType && 8! == d.nodeType &&! X.test (q + n.event.triggered) && (q.indexOf (".")> = 0 && (r = q.split ("."), q = r.shift (), r.sort ()), k = q.indexOf (":") <0 && "em" + q, b = b [n.expando]? B: novo n.Event (q, "object" == typeof b && b), b.isTrigger = e? 2: 3, b.namespace = r .Junte-se("."), b.namespace_re = b.namespace? novo RegExp (" (^ | \\.) "+ r.join (" \\. (?:. * \\. |) ") +" (\\. | $) "): null, b.result = void 0, b.target || (b.target = d), c = null == c? [b]: n.makeArray (c, [b]), o = n.event.special [q] || {}, e ||! o.trigger || o.trigger.apply (d, c)! ==! 1)) {if (! e &&! o.noBubble && ! n.isWindow (d)) {for (i = o.delegateType || q, X.test (i + q) || (g = g.parentNode); g; g = g.parentNode) p.push ( g) h = g; h === (d.ownerDocument || l) && p.push (h.defaultView || h.parentWindow || a)} f = 0; while ((g = p [f ++]) &&! b.isPropagationStopped ()) b.type = f> 1? i: o.bindType || q, m = (L.get (g, "events") || {}) [b.type] && L. get (g, "handle"), m && m.apply (g, c), m = k && g [k], m && m.apply && n.acceptData (g) && (b.result = m.apply (g, c), b. resultado ===! 1 && b.preventDefault ()); return b.type = q, e || b.isDefaultPrevented () || o._default && o._default.apply (p.pop (), c)! ==! 1 ||! n.acceptData (d) || k && n.isFunction (d [q]) &&! n.isWindow (d) && (h = d [k], h && (d [k] = null), n.event.triggered = q, d [q] (), n.event.triggered = void 0, h && (d [k] = h)) , b.result}}, dispatch: function (a) {a = n.event.fix (a); var b, c, e, f, g, h = [], i = d.call (argumentos), j = (L.get (this, "events") || {}) [a.type] || [], k = n.event.special [a.type] || {}; if (i [0 ] = a, a.delegateTarget = this,! k.preDispatch || k.preDispatch.call (this, a)! ==! 1) {h = n.event.handlers.call (this, a, j), b = 0; while ((f = h [b ++]) &&! a.isPropagationStopped ()) {a.currentTarget = f.elem, c = 0; while ((g = f.handlers [c ++]) &&! a .isImmediatePropagationStopped ()) (! a.namespace_re || a.namespace_re.test (g.namespace)) && (a.handleObj = g, a.data = g.data, e = ((n.event.special [g .origType] || {}). handle || g.handler) .apply (f.elem, i), void 0! == e && (a.result = e) ===! 1 && (a.preventDefault (), a.stopPropagation ()))} retornar k.postDispatch && k.postDispatch.call (isto, a), a.result}}, manipuladores: função (a, b) {var c, d, e, f, g = [], h = b.delegateCount, i = a.target; if (h && i.nodeType && (! a.button || "clique"! == a.type ) para (; i! == isto; i = i.parentNode || this) if (i.disabled! ==! 0 || "clique"! == a.type) {for (d = [], c = 0; h> c; c ++) f = b [c], e = f.selector + "", void 0 === d [e] && (d [e] = f.needsContext? n (e, this ) .index (i)> = 0: n.find (e, this, null, [i]). length), d [e] && d.push (f); d.length && g.push ({elem: i, manipuladores: d})} return h <b.length && g.push ({elem: this, handlers: b.slice (h)}), g}, adereços: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which ".split (" "), fixHooks: {}, keyHooks: {props:"char charCode key keyCode ".split (" "), filtro: function (a, b) {return null == a.which && (a.which = null! = b.charCode? b.charCode: b.keyCode), a }}, mouseHooks: botões de botão {appits: "clientX clientY offsetX offsetY pageX pageY screenX screenY toElement" .split (""), filtro: função (a, b) {var c, d, e, f = b.button; return null == a.pageX && null! = b.clientX && (c = a.target.ownerDocument || l, d = c.documentElement, e = c.body, a.pageX = b.clientX + (d && d.scrollLeft || e && e .scrollLeft || 0) - (d && d.clientLeft || e && e.clientLeft || 0), a.pageY = b.clientY + (d && d.scrollTop || e && e.scrollTop || 0) - (d && d.clientTop || e && e. clientTop || 0)), a.which || void 0 === f || (a.which = 1 & f? 1: 2 & f? 3: 4 & f? 2: 0), a}}, corrigir: função (a) {if (a [n.expando]) retorna a; var b, c, d, e = a.type, f = a, g = this.fixHooks [e]; g || (this.fixHooks [e] = g = W.test (e)? this.mouseHooks: V.test (e)? this.keyHooks: {}), d = g.props? this.props.concat (g.props): this.props, a = new n.Event (f), b = d.length; enquanto (b -) c = d [b], a [c] = f [c]; retorna a.target || ( a.target = l), 3 === a.target.nodeType && (a.target = a.target.parentNode), g.filter? g.filter (a, f): a}, especial: {carregar: { noBubble:! 0}, foco: {trigger: function () {return this! == _ () && this.focus? (this.focus () ,! 1): void 0}, delegateType: "focusin"}, borrão : {trigger: function () {return this === _ () && this.blur? (this.blur () ,! 1): void 0}, delegateType: "focusout"}, clique: {trigger: function () {return "checkbox" === this.type && this.click && n.nodeName (this, "input")? (this.click () ,! 1): void 0}, _ default: function (a) {return n.nodeName ( a.target, "a")}}, antes da carga: {postDispatch: function (a) {void 0! == a.result && a.originalEvent && (a.originalEvent.returnValue = a.result)}}}, simule: função (a, b, c, d) {var e = n.extend (novo n.Event, c, {type: a, isSimulated: ! 0, originalEvent: {}}); d? N.event.trigger (e, null, b): n.event.dispatch.call (b, e), e.isDefaultPrevented () && c.preventDefault ()}} , n.removeEvent = função (a, b, c) {a.removeEventListener && a.removeEventListener (b, c,! 1)}, n.Event = function (a, b) {return this instanceof n.Event? (a && a. digite? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue ===! 1? Z: $): this.type = a, b && n.extend (this, b), this.timeStamp = a && a.timeStamp || n.now (), void (this [n.expando] =! 0)): new n.Event (a, b) }, n.Event.prototype = {isDefaultPrevented: $, isPropagationStopped: $, isImmediatePropagationStopped: $, preventDefault: function () {var a = this.originalEvent;this.isDefaultPrevented = Z, a && a.preventDefault && a.preventDefault ()}, stopPropagation: function () {var a = this.originalEvent; this.isPropagationStopped = Z, a && a.stopPropagation && a.stopPropagation ()}, stopImmediatePropagation: function () {var a = this.originalEvent; this.isImmediatePropagationStopped = Z, a && a.stopImmediatePropagation && a.stopImmediatePropagation (), this.stopPropagation ()}}, n.each ({mouseenter: "mouseover", mouseleave: "mouseout", ponteiro: "ponteiro" pointerleave: "pointerout"}, função (a, b) {n.event.special [a] = {delegateType: b, bindType: b, handle: function (a) {var c, d = this, e = a .relatedTarget, f = a.handleObj; return (! e || e! == d &&! n.contains (d, e)) && (a.type = f.origType, c = f.handler.apply (isto, argumentos), a.type = b), c}}}), k.focusinBubbles || n.each ({focus: "focusin ", borrão:" focusout "}, função (a, b) {var c = função (a) {n.event.simulate (b, a.target, n.event.fix (a) ,! 0)} ; n.event.special [b] = {setup: function () {var d = this.ownerDocument || this, e = L.access (d, b); e || d.addEventListener (a, c ,! 0), L.access (d, b, (e || 0) +1)}, lágrima: function () {var d = this.ownerDocument || this, e = L.access (d, b) -1 ; e? L.access (d, b, e) :( d.removeEventListener (a, c,! 0), L.remove (d, b))}}}), n.fn.extend ({on: função (a, b, c, d, e) {var f, g; if ("object" == typeof a) {"string"! = typeof b && (c = c || b, b = void 0); para (g em a) this.on (g, b, c, a [g], e); devolva isso} se (null == c && null == d? (d = b, c = b = void 0): null == d && ("string" == typeof b? (d = c, c = void 0) :( d = c, c = b, b = void 0)), d ===! 1) d = $ ; senão se (! d) retornar isto; retornar 1 === e && (f = d, d = função (a) {return n (). off (a), f.apply (this, arguments)}, d. guid = f.guid || (f.guid = n.guid ++)), isto.cada (função () {n.event.add (this, a, d, c, b)})}, one: function (a, b, c, d) {return this.on (a, b, c, d, 1)}, off: function (a, b, c) {var d, e; if (a && a.preventDefault && a.handleObj) retornam d = a.handleObj, n (a.delegateTarget) .off (d.namespace? d.origType + "." + d.namespace: d.origType, d.selector, d.handler), this; if ("object" == typeof a) {para (e em a) this.off (e, b , a [e]); retorna este} retorno (b ===! 1 || "função" == typeof b) && (c = b, b = void 0), c ===! 1 && (c = $ ), this.each (function () {n.event.remove (this, a, c, b)})}, trigger: function (a, b) {return this.each (function () {n.event. trigger (a, b, this)})}, triggerHandler: function (a, b) {var c = this [0]; return c? n.event.trigger (a, b, c,! 0): void 0 }}); var ab = / <(?! área | br | col | embed | hr | img | input | link | meta | param) (([\ w:] +) [^>] *) \ /> / gi, bb = / <([\ w:] +) /, cb = / <| & #? \ w +; /, db = / <(?: script | style | link) / i,eb = / checked \ s * (?: [^ =] | = \ s * .checked.) / i, fb = / ^ $ | \ / (?: java | ecma) script / i, gb = / ^ true \ / (. *) /, hb = / ^ \ s * <! (?: \ [CDATA \ [| -) | (?: \] \] | -)> \ s * $ / g, ib = {opção: [1, "<selecione múltiplo = 'múltiplo'>", "</ select>"], thead: [1, "<table>", "</ table>"], col: [2, "<table> <colgroup>", "</ colgroup> </ table>"], tr: [2, "<table> <tbody>", "</ tbody> </ table>"], td: [ 3, "<table> <tbody> <tr>", "</ tr> </ tbody> </ table>"], _ default: [0, "", ""]}; ib.optgroup = ib.option ib.tbody = ib.tfoot = ib.colgroup = ib.caption = ib.thead, ib.th = ib.td; function jb (a, b) {return n.nodeName (a, "table") && n. nodeName (11! == b.nodeType? b: b.firstChild, "tr")? a.getElementsByTagName ("tbody") [0] || a.appendChild (a.ownerDocument.createElement ("tbody")): a} função kb (a) {return a.type = (null! == a.getAttribute (" tipo ")) +" / "+ a.type, a} função lb (a) {var b = gb.exec (a.type); retornar b? a.type = b [1]: a.removeAttribute (" digite "), a} função mb (a, b) {para (var c = 0, d = a.length; d> c; c ++) L.set (a [c]," globalEval ",! b || L.get (b [c], "globalEval"))} função nb (a, b) {var c, d, e, f, g, h, i, j; se (1 === b.nodeType) {if (L.hasData (a) && (f = L.access (a), g = L.set (b, f), j = f.events)) {delete g.handle, g.events = {} ; para (e em j) para (c = 0, d = j [e] .length; d> c; c ++) n.event.add (b, e, j [e] [c])} M.hasData (a) && (h = M.accesso (a), i = n.extend ({}, h), M.set (b, i))}} função ob (a, b) {var c = a. getElementsByTagName? a.getElementsByTagName (b || "*"): a.querySelectorAll? a.querySelectorAll (b || "*"): [];retornar vazio 0 === b || b && n.nodeName (a, b)? n.merge ([a], c): c} função pb (a, b) {var c = b.nodeName.toLowerCase (); "input" === c && T.test (a.type)? b.checked = a.checked :( "input" === c || "textarea" === c) && (b.defaultValue = a.defaultValue )} n.extend ({clone: ​​function (a, b, c) {var d, e, f, g, h = a.cloneNode (! 0), i = n.contains (a.ownerDocument, a); se (! (k.noCloneChecked || 1! == a.nodeType && 11! == a.nodeType || n.isXMLDoc (a))) para (g = ob (h), f = ob (a), d = 0, e = f.length; e> d; d ++) pb (f [d], g [d]); se (b) se (c) for (f = f || ob (a), g = g || ob (h), d = 0, e = f.length; e> d; d ++) nb (f [d], g [d]); else nb (a, h); retornar g = ob (h , "script"), g.length> 0 && mb (g,! i && ob (a, "script")), h}, buildFragment: function (a, b, c, d) {para (var e, f, g, h, i, j, k = b.createDocumentFragment (), l = [], m = 0, o = a.length; o> m; m ++) se (e = a [m], e || 0 == = e) if ("object" === n.type (e)) n.mesclar (l, e.nodeType? [e]: e); senão se (cb.test (e)) {f = f || k.appendChild (b.createElement ("div")), g = (bb. exec (e) || ["", ""]) [1] .toLowerCase (), h = ib [g] || ib._default, f.innerHTML = h [1] + e.replace (ab, " <$ 1> </ $ 2> ") + h [2], j = h [0]; enquanto (j -) f = f.lastChild; n.merge (l, f.childNodes), f = k.firstChild , f.textContent = ""} else l.push (b.createTextNode (e)); k.textContent = "", m = 0; while (e = l [m ++]) se ((! d || -1 === n.inArray (e, d)) && (i = n.contains (e.ownerDocument, e), f = ob (k.appendChild (e), "script"), i && mb (f), c) ) {j = 0; while (e = f [j ++]) fb.test (e.type || "") && c.push (e)} return k}, cleanData: function (a) {for (var b, c, d, e, f = n.event.special, g = 0; void 0! == (c = a [g]); g ++) {if (n.acceptData (c) && (e = c [L .expando], e && (b = L.cache [e]))) {if (b.events) for (d in b.events) f [d]? n.event.remove (c, d): n.removeEvent (c, d, b.handle); L.cache [e] && delete L.cache [e]} delete M.cache [c [M.expando]]}}}), n.fn.extend ({text : function (a) {return J (this, function (a) {return void 0 === a? n.text (this): this.empty (). each (function () {(1 === isto. nodeType || 11 === this.nodeType || 9 === this.nodeType) && (this.textContent = a)})}, null, a, arguments.length)}, anexar: function () {return this .domManip (argumentos, função (a) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var b = jb (this, a); b .appendChild (a)}})}, prepend: function () {return this.domManip (argumentos, função (a) {if (1 === this.nodeType || 11 === this.nodeType || 9 = == this.nodeType) {var b = jb (this, a); b.insertBefore (a, b.firstChild)}})}, antes: function () {return this.domManip (argumentos, função (a) { this.parentNode && this.parentNode.insertBefore (a, this)})}, depois: function () {return this.domManip (argumentos, função (a) {this.parentNode && this.parentNode.insertBefore (a, this.nextSibling)})}, remove: function (a, b) {for (var c, d = a? n.filter (a, this): this, e = 0; null ! = (c = d [e]); e ++) b || 1! == c.nodeType || n.cleanData (ob (c)), c.parentNode && (b && n.contains (c.ownerDocument, c) && mb (ob (c, "script")), c.parentNode.removeChild (c)); return this}, empty: function () {for (var a, b = 0; null! = (a = this [b] ); b ++) 1 === a.nodeType && (n.cleanData (ob (a,! 1)), a.textContent = ""); return this}, clone: ​​function (a, b) {return a = null == a?! 1: a, b = null == b? a: b, this.map (function () {return n.clone (this, a, b)})}, html: function (a) { retornar J (isto, função (a) {var b = this [0] || {}, c = 0, d = this.length; if (void 0 === a && 1 === b.nodeType) retornar b. inner (), = a.replace (ab,"<$ 1> </ $ 2>"); tente {para (; d> c; c ++) b = this [c] || {}, 1 === b.nodeType && (n.cleanData (ob (b ,!) 1)), b.innerHTML = a); b = 0} catch (e) {}} b && this.empty (). Append (a)}, null, a, arguments.length)}, replaceWith: function () { var a = argumentos [0]; retornar this.domManip (argumentos, função (b) {a = this.parentNode, n.cleanData (ob (this)), a && a.replaceChild (b, this)}), a && (a .length || a.nodeType)? this: this.remove ()}, detach: function (a) {return this.remove (a,! 0)}, domManip: função (a, b) {a = e. Aplicar ([], a); var c, d, f, g, h, i, j = 0, l = this.length, m = this, o = l-1, p = a [0], q = n.isFunction (p); if (q || l> 1 && "string" == typeof p &&! k.checkClone && eb.test (p)) retorna this.each (function (c) {var d = m.eq (c ); q && (a [0] = p.call (isto, c, d.html ())), d.domManip (a, b)}); se (l && (c = n.buildFragment (a, this [ 0] .ownerDocument,! 1, this), d = c.firstChild,1 === c.childNodes.length && (c = d), d)) {for (f = n.map (ob (c, "script"), kb), g = f.length; l> j; j ++ ) h = c, j! == o && (h = n.clone (h,! 0,! 0), g && n.merge (f, ob (h, "script"))), b.call (this [j ], h, j); se (g) for (i = f [f.length-1] .ownerDocument, n.map (f, lb), j = 0; g> j; j ++) h = f [j ], fb.test (h.type || "") &&! L.access (h, "globalEval") && n.contains (i, h) && (h.src? n._evalUrl && n._evalUrl (h.src) : n.globalEval (h.textContent.replace (hb, "")))} return this}}), n.each ({appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "depois", replaceAll: "replaceWith"}, função (a, b) {n.fn [a] = função (a) {para (var c, d = [], e = n (a), g = e .length-1, h = 0; g> = h; h ++) c = h === g? this: this.clone (! 0), n (e [h]) [b] (c), f. aplicar (d, c.get ()); retornar this.pushStack (d)}}); var qb, rb = {};função sb (b, c) {var d, e = n (c.createElement (b)). appendTo (c.body), f = a.getDefaultComputedStyle && (d = a.getDefaultComputedStyle (e [0]))? d .display: n.css (e [0], "display"); retornar e.detach (), f} função tb (a) {var b = l, c = rb [a]; retornar c || (c = sb (a, b), "none"! == c && c || (qb = (qb || n ("<iframe frameborder = '0' width = '0' height = '0' />")). appendTo (b.documentElement), b = qb [0] .contentDocument, b.write (), b.close (), c = sb (a, b), qb.detach ()), rb [a] = c ), c} var ub = / ^ margem /, vb = novo RegExp ("^ (" + Q + ") (?! px) [az%] + $", "i"), wb = função (a) { retornar a.ownerDocument.defaultView.getComputedStyle (a, null)}; função xb (a, b, c) {var d, e, f, g, h = a.style; return c = c || wb (a) , c && (g = c.getPropertyValue (b) || c [b]), c && (""! == g || n.contains (a.ownerDocument, a) || (g = n.style (a, b)), vb.test (g) &&ub.test (b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0! == g? g + "": g} função yb (a, b) {return {get: function () {return a ()? void delete this.get: (this.get = b) .apply (this, arguments)}}}! function () {var b, c, d = l.documentElement, e = l.createElement ("div"), f = l.createElement ("div"); se (f.style) {f.style.backgroundClip = "content-box", f.cloneNode (! 0) .style.backgroundClip = "", k.clearCloneStyle = " content-box "=== f.style.backgroundClip, e.style.cssText =" border: 0; width: 0; height: 0; top: 0; left: -9999px; margin-top: 1px; position: absolute ", e.appendChild (f); function g () {f.style.cssText =" - webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box ; display: bloco; margem superior: 1%; superior: 1%; borda: 1px; preenchimento: 1px; largura:4px; posição: absoluta ", f.innerHTML =" ", d.appendChild (e); var g = a.getComputedStyle (f, null); b =" 1% "! == g.top, c =" 4px "=== g.width, d.removeChild (e)} a.getComputedStyle && n.extend (k, {pixelPosition: function () {return g (), b}, boxSizingReliable: function () {return null == c && g ( ), c}, reliableMarginRight: function () {var b, c = f.appendChild (l.createElement ("div")); retornar c.style.cssText = f.style.cssText = "- webkit-box-sizing : content-box; -moz-box-sizing: content-box; box-sizing: content-box; display: block; margin: 0; border: 0; padding: 0 ", c.style.marginRight = c.style .width = "0", f.style.width = "1px", d.appendChild (e), b =! parseFloat (a.getComputedStyle (c, null) .marginRight), d.removeChild (e), b} })}} (), n.swap = função (a, b, c, d) {var e, f, g = {}; para (f em b) g [f] = a.style [f], a.style [f] = b [f]; e = c.apply (a, d || []);para (f em b) a.style [f] = g [f]; retornar e}; var zb = / ^ (nenhuma | tabela (?! - c [ea]). +) /, Ab = novo RegExp ( "^ (" + Q + ") () *) $", "i"), Bb = novo RegExp ("^ ([+ -]) = (" + Q + ")", "i"), Cb = { Posição: "absoluto", visibilidade: "oculto", exibir: "bloco"}, Db = {letterSpacing: "0", fontWeight: "400"}, Eb = ["Webkit", "O", "Moz" "ms"]; função Fb (a, b) {se (b em a) retornar b; var c = b [0] .toUpperCase () + b.slice (1), d = b, e = Eb.length ; enquanto (e -) se (b = Eb [e] + c, b em a) retornar b; retornar d} função Gb (a, b, c) {var d = Ab.exec (b); return d ? Math.max (0, d [1] - (c || 0)) + (d [2] || "px"): b} função Hb (a, b, c, d, e) {para ( var f = c === (d? "border": "content")? 4: "width" === b? 1: 0, g = 0; 4> f; f + = 2) "margem" == = c && (g + = n.css (a, c + R [f], 0, e)), d? ("conteúdo"=== c && (g- = n.css (a, "padding" + R [f], 0, e)), "margem"! == c && (g- = n.css (a, "border" + R [f] + "Largura",! 0, e))) :( g + = n.css (a, "padding" + R [f], 0, e), "padding"! == c && ( g + = n.css (a, "border" + R [f] + "Width",! 0, e))); return g} função Ib (a, b, c) {var d =! 0, e = "width" === b? a.offsetWidth: a.offsetHeight, f = wb (a), g = "border-box" === n.css (a, "boxSizing",! 1, f); se (0> = e || null == e) {if (e = xb (a, b, f), (0> e || null == e) && (e = a.style [b]), vb .test (e)) return e; d = g && (k.boxSizingReliable () || e === a.style [b]), e = parseFloat (e) || 0} retornar e + Hb (a, b c || (g? "border": "content"), d, f) + função "px"} Jb (a, b) {para (var c, d, e, f = [], g = 0 , h = a.length; h> g; g ++) d = a [g], d.style && (f [g] = L.get (d, "olddisplay"), c = d.style.display, b? (f [g] || "nenhum "! == c || (d.style.display =" ")," "=== d.style.display && S (d) && (f [g] = L.access (d," olddisplay ", tb (d.nodeName))) :( e = S (d), "none" === c && e || L.set (d, "olddisplay", e? c: n.css (d, "display") ))); para (g = 0; h> g; g ++) d = a [g], d.style && (b && "none"! == d.style.display && ""! == d.style.display | | (d.style.display = b? f [g] || "": "none")); return a} n.extend ({cssHooks: {opacity: {get: function (a, b) {if ( b) {var c = xb (a, "opacidade"); return "" === c? "1": c}}}}, cssNumber: {columnCount:! 0, fillOpacity:! 0, flexGrow:! 0 FlexShrink: 0, fontWeight:! 0, lineHeight:! 0, opacidade:! 0, ordem:! 0, órfãos:! 0, widows:! 0, zIndex:! 0, zoom:! 0}, cssProps: { "float": "cssFloat"}, estilo: função (a, b, c, d) {if (a && 3! == a.nodeType &&8! == a.nodeType && a.style) {var e, f, g, h = n.camelCase (b), i = a.style; return b = n.cssProps [h] || (n.cssProps [h ] = Fb (i, h)), g = n.cssHooks [b] || n.cssHooks [h], void 0 === c? G && "get" in g && void 0! == (e = g.get (a,! 1, d))? e: i [b] :( f = typeof c, "string" === f && (e = Bb.exec (c)) && (c = (e [1] + 1) * e [2] + parseFloat (n.css (a, b)), f = "número"), null! = C && c === c && ("número"! == f || n.cssNumber [h ] || (c + = "px"), k.clearCloneStyle || ""! == c || 0! == b.indexOf ("background") || (i [b] = "herdar"), g && "set" em g && void 0 === (c = g.set (a, c, d)) || (i [b] = c)), void 0)}}, css: função (a, b, c , d) {var e, f, g, h = n.camelCase (b); return b = n.cssProps [h] || (n.cssProps [h] = Fb (a.style, h)), g = n.cssHooks [b] || n.cssHooks [h], g && "get" in g && (e = g.get (a,! 0, c)), void 0 === e &&(e = xb (a, b, d)), "normal" === e && b em Db && (e = Db [b]), "" === c || c? (f = parseFloat (e), c ===! 0 || n.isNumeric (f)? F || 0: e): e}}), n.each (["altura", "largura"], função (a, b) {n. cssHooks [b] = {get: function (a, c, d) {return c? zb.test (n.css (a, "display")) && 0 === a.offsetWidth? n.swap (a, Cb , function () {return Ib (a, b, d)}): Ib (a, b, d): void 0}, set: function (a, c, d) {var e = d && wb (a); return Gb (a, c, d? Hb (a, b, d, "border-box" === n.css (a, "boxSizing",! 1, e), e): 0)}}}) n.cssHooks.marginRight = yb (k.reliableMarginRight, função (a, b) {return b? n.swap (a, {display: "inline-block"}, xb, [a, "marginRight"]): void 0}), n.each ({margem: "", preenchimento: "", borda: "Largura"}, função (a, b) {n.cssHooks [a + b] = {expandir: function (c) { para (var d = 0, e = {}, f = "string" == typeof c? c.split (""): [c]; 4> d; d ++) e [a + R [d] + b] = f [d] || f [d-2] || f [0]; return e}}, ub .test (a) || (n.cssHooks [a + b] .set = Gb)}), n.fn.extend ({css: function (a, b) {return J (this, function (a, b c) {var d, e, f = {}, g = 0; if (n.isArray (b)) {para (d = wb (a), e = b.length; e> g; g ++) f [b [g]] = n.css (a, b [g], 1, d); return f} return void 0! == c? n.style (a, b, c): n.css ( a, b)}, a, b, arguments.length> 1)}, show: function () {return Jb (this,! 0)}, hide: function () {return Jb (this)}, alternar: function (a) {return "boolean" == typeof a? a? this.show (): this.hide (): this.each (function () {S (this)? n (this) .show (): n (este) .hide ()})}}); função Kb (a, b, c, d, e) {retorna o novo Kb.prototype.init (a, b, c, d, e)} n.Tween = Kb, Kb.prototype = {constructor: Kb, init: function (a, b, c, d, e, f) {this.elem = a, this.prop = c, this.easing = e || "swing" , this.options = b, this.start = this.now = this.cur (), this.end = d, this.unit = f || (n.cssNumber [c]? "": "px")} ,cur: function () {var a = Kb.propHooks [this.prop]; retorna um && a.get? a.get (este): Kb.propHooks._default.get (this)}, execute: function (a) {var b, c = Kb.propHooks [this.prop]; retorna this.pos = b = this.options.duration? n.easing [this.easing] (a, this.options.duration * a, 0,1, this .options.duration): a, this.now = (this.end-this.start) * b + this.start, this.options.step && this.options.step.call (this.elem, this.now, this) , c && c.set? c.set (isto): Kb.propHooks._default.set (this), this}}, Kb.prototype.init.prototype = Kb.prototype, Kb.propHooks = {_ default: {get: function (a) {var b; return null == a.elem [a.prop] || a.elem.style && null! = a.elem.style [a.prop]? (b = n.css (a.elem, a.prop, ""), b && "auto"! == b? b: 0): a.elem [a.prop]}, set: function (a) {n.fx.step [a.prop]? n.fx.step [a.prop] (a): a.elem.style && (null! = a.elem.style [n.cssProps [a.prop]] || n.cssHooks [a.prop])? n.style (a.elem, a.prop, a.now + a.unit): a.elem [a.prop] = a.now}}}, Kb.propHooks.scrollTop = Kb.propHooks .scrollLeft = {set: function (a) {a.elem.nodeType && a.elem.parentNode && (a.elem [a.prop] = a.now)}}, n.easing = {linear: function (a) {return a}, swing: function (a) {return.5-Math.cos (a * Math.PI) / 2}}, n.fx = Kb.prototype.init, n.fx.step = {}; var Lb , Mb, Nb = / ^ (?: toggle | show | hide) $ /, Ob = novo RegExp ("^ (?: ([+ -]) = |) (" + Q + ") ([az%] * ) $, "i"), Pb = / queueHooks $ /, Qb = [Vb], Rb = {"*": [function (a, b) {var c = this.createTween (a, b), d = c.cur (), e = Ob.exec (b), f = e && e [3] || (n.cssNumber [a]? "": "px"), g = (n.cssNumber [a] | | "px"! == f && + d) && Ob.exec (n.css (c.elem, a)), h = 1, i = 20; se (g && g [3]! == f) {f = f || g [3], e = e || [], g = + d || 1; do h = h || ".5", g / = h, n.style (c.elem, a, g + f); enquanto (h! == (h = c.cur () / d) && 1!== h && - i)} retornar e && (g = c.start = + g || + d || 0, c.unidade = f, c.end = e [1]? g + (e [1] +1 ) * e [2]: + e [2]), c}]}; função Sb () {return setTimeout (função () {Lb = void 0}), Lb = n.now ()} função Tb (a b) {var c, d = 0, e = {altura: a}; para (b = b? 1: 0; 4> d; d + = 2-b) c = R [d], e ["margem "+ c] = e [" preenchimento "+ c] = a; return b && (e.opacity = e.width = a), e} função Ub (a, b, c) {para (var d, e = ( Rb [b] || []). Concat (Rb ["*"]), f = 0, g = e.length; g> f; f ++) se (d = e [f] .call (c, b , a)) return d} função Vb (a, b, c) {var d, e, f, g, h, i, j, k, l = isto, m = {}, o = a.style, p = a.nodeType && S (a), q = L.get (a, "fxshow"); c.queue || (h = n._queueHooks (a, "fx"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function () {h.unqueued || i ()}), h.unqueued ++, l.always (function () {l.always (função ( ) {h.unqueued -, n.queue (a, "fx"). comprimento || h.empty.fire ()})})), 1 === a.nodeType && ("height" em b || "width" em b) && (c.overflow = [o.overflow, o.overflowX, o.overflowY], j = n.css (a, "display"), k = "none" === j? L.get (a, "olddisplay") || tb (a.nodeName): j, "inline" === k && "none" === n.css (a, "float ") && (o.display =" inline-block ")), c.overflow && (o.overflow =" hidden ", l.always (function () {o.overflow = c.overflow [0], o.overflowX = c.overflow [1], o.overflowY = c.overflow [2]})); para (d em b) se (e = b [d], Nb.exec (e)) {if (delete b [ d] f = f || "toggle" === e, e === (p? "hide": "show")) {if ("show"! == e ||! q || void 0 === q [d]) continue; p =! 0} m [d] = q && q [d] || n.style (a, d)} else j = void 0; if (n.isEmptyObject (m)) "inline" === ("none" === j? tb (a.nodeName): j) && (o.display = j); else {q? "hidden"em q && (p = q.hidden): q = L.access (a, "fxshow", {}), f && (q.hidden =! p), p? n (a) .show (): l.done (function () {n (a) .hide ()}), l.done (function () {var b; L.remove (a, "fxshow"); para (b em m) n.style (a, b, m [b])}); para (d em m) g = Ub (p? q [d]: 0, d, l), d em q || (q [d] = g.start, p && (g.end = g.start, g.start = "width" === d || "height" === d? 1: 0))}} função Wb (a, b) {var c, d, e, f, g; para (c em a) if (d = n.camelCase (c), e = b [d], f = a [c], n.isArray (f) && (e = f [1 ], f = a [c] = f [0]), c! == d && (a [d] = f, delete a [c]), g = n.cssHooks [d], g && "expandir" em g ) {f = g.expand (f), delete a [d]; para (c em f) c em a || (a [c] = f [c], b [c] = e)} else b [ d] = e} função Xb (a, b, c) {var d, e, f = 0, g = Qb.length, h = n.Deferred (). always (function () {delete i.elem}) i = function () {if (e) return! 1; for (var b = Lb || Sb (), c = Math.max (0, j.startTime + j.duration-b), d = c / j.duration || 0, f = 1-d, g = 0, i = j.tweens.length; i> g; g ++) j.tweens [g] .run (f); return h.notifyWith (a, [j, f, c]), 1> f && i? c: (h.resolveWith (a, [ j]), 1)}, j = h.promise ({elem: a, props: n.extend ({}, b), opts: n.extend (! 0, {specialEasing: {}}, c) , originalProperties: b, originalOptions: c, startTime: Lb || Sb (), duração: c.duration, tweens: [], createTween: function (b, c) {var d = n.Tween (a, j.opts , b, c, j.opts.specialEasing [b] || j.opts.easing); return j.tweens.push (d), d}, stop: function (b) {var c = 0, d = b ? j.tweens.length: 0; se (e) retornar isso; para (e =! 0; d> c; c ++) j.tweens [c] .run (1); retornar b? h.resolveWith (a, [j, b]): h.rejectWith (a, [j, b]), this}}), k = j.props; para (Wb (k, j.opts.specialEasing); g> f; f ++) se (d = Qb [f] .call (j, a, k, j.opts)) retornar d; return n.map (k, Ub, j), n.isFunction (j.opts.start) && j.opts .start.call (a, j), n.fx.timer (n.extend (i, {elem: a, anim: j, fila: j.opts.queue})), j.progress (j.opts. progresso) .done (j.opts.done, j.opts.complete).fail (j.opts.fail) .always (j.opts.always)} n.Animation = n.extend (Xb, {tweener: function (a, b) {n.isFunction (a)? (b = a, a = ["*"]): a = a.split (""); para (var c, d = 0, e = a.length; e> d; d ++) c = a [d], Rb [c ] = Rb [c] || [], Rb [c] .unshift (b)}, prefiltro: função (a, b) {b? Qb.unshift (a): Qb.push (a)}}), n.speed = function (a, b, c) {var d = a && "object" == typeof a? n.extend ({}, a): {complete: c ||! c && b || n.isFunction (a ) && a, duração: a, facilitando: c && b || b &&! n.isFunction (b) && b}; return d.duration = n.fx.off? 0: "number" == typeof d.duration? d.duration: d.duration em n.fx.speeds? n.fx.speeds [d.duration]: n.fx.speeds._default, (null == d.queue || d.queue ===! 0) && (d .queue = "fx"), d.old = d.complete, d.complete = function () {n.isFunction (d.old) && d.old.call (this), d.queue && n.dequeue (this, d .queue)}, d}, n.fn.extend ({fadeTo:função (a, b, c, d) {retorna this.filter (S) .css ("opacity", 0) .show (). end (). animate ({opacity: b}, a, c, d) }, animate: function (a, b, c, d) {var e = n.isEmptyObject (a), f = n.speed (b, c, d), g = function () {var b = Xb (isto , n.extend ({}, a), f); (e || L.get (this, "finish")) && b.stop (! 0)}; retornar g.finish = g, e || f. fila ===! 1? this.each (g): this.queue (f.queue, g)}, stop: function (a, b, c) {var d = function (a) {var b = a. Parar, apagar a.stop, b (c)}; retornar "string"! = typeof a && (c = b, b = a, a = void 0), b && a! ==! 1 && this.queue (a || "fx ", []), this.each (function () {var b =! 0, e = null! = a && a +" queueHooks ", f = n.timers, g = L.get (este); se (e) g [e] && g [e] .stop && d (g [e]); senão para (e em g) g [e] && g [e] .stop && Pb.test (e) && d (g [e]); para (e = f.length; e -;) f [e] .elem! == este || null! = a && f [e] .queue! == a || (f [e] .anim.stop (c), b =! 1,f.splice (e, 1)); (b ||! c) && n.dequeue (this, a)})}, termine: function (a) {return a! ==! 1 && (a = a || " fx "), this.each (function () {var b, c = L.get (this), d = c [a +" fila "], e = c [a +" queueHooks "], f = n.timers, g = d? d.length: 0; para (c.finish =! 0, n.queue (this, a, []), e && e.stop && e.stop.call (this,! 0), b = f.length ; b -;) f [b] .elem === este && f [b] .queue === a && (f [b] .anim.stop (! 0), f.splice (b, 1)) para (b = 0; g> b; b ++) d [b] && d [b] .finish && d [b] .finish.call (this); delete c.finish})}}), n.each (["alternar" "show", "hide"], função (a, b) {var c = n.fn [b]; n.fn [b] = função (a, d, e) {return null == a || "boolean" == typeof a? c.apply (this, arguments): this.animate (Tb (b,! 0), a, d, e)}}), n.each ({slideDown: Tb ("mostrar "), slideUp: Tb (" hide "), slideToggle: Tb (" toggle "), fadeIn: {opacidade:"show"}, fadeOut: {opacity: "hide"}, fadeToggle: {opacity: "toggle"}}, função (a, b) {n.fn [a] = função (a, c, d) {return this.animate (b, a, c, d)}}), n.timers = [], n.fx.tick = function () {var a, b = 0, c = n.timers; para (Lb = n.now (); b <c.length; b ++) a = c [b], a () || c [b]! == a || c.splice (b -, 1); c.length || n.fx.stop (), Lb = void 0}, n.fx.timer = função (a) {n.timers.push (a), a ()? n.fx.start (): n. timers.pop ()}, n.fx.interval = 13, n.fx.start = function () {Mb || (Mb = setInterval (n.fx.tick, n.fx.interval))}, n. fx.stop = function () {clearInterval (Mb), Mb = null}, n.fx.speeds = {lento: 600, rápido: 200, _default: 400}, n.fn.delay = função (a, b) {return a = n.fx? n.fx.speeds [a] || a: a, b = b || "fx", this.queue (b, função (b, c) {var d = setTimeout (b , a); c.stop = function () {clearTimeout (d)}})}, function () {var a = l.createElement ("input"), b = l.createElement ("select"), c = b.appendChild (l.createElement ("opção")); a.type = "checkbox", k.checkOn = ""! == a.value, k.optSelected = c.selected, b.disabled =! 0, k.optDisabled =! c .disabled, a = l.createElement ("input"), a.value = "t", a.type = "radio", k.radioValue = "t" === a.value} (); var Yb, Zb, $ b = n.expr.attrHandle; n.fn.extend ({attr: function (a, b) {return J (this, n.attr, a, b, arguments.length> 1)}, removeAttr: função (a) {return this.each (function () {n.removeAttr (this, a)})}}), n.extend ({attr: function (a, b, c) {var d, e, f = a.nodeType; if (a && 3! == f && 8! == f && 2! == f) return typeof a.getAttribute === U? n.prop (a, b, c) :( 1 === f && n.isXMLDoc (a) || (b = b.toLowerCase (), d = n.attrHooks [b] || (n.expr.match.bool.test (b)? Zb: Yb)), void 0 === c ? d && "get" em d && null! == (e = d.get (a, b))? e: (e = n.find.attr (a, b), null == e? void 0: e): null! == c? d &&"set" em d && void 0! == (e = d.set (a, c, b))? e: (a.setAttribute (b, c + ""), c): void n.removeAttr (a, b) )
}, removeAttr: function (a, b) {var c, d, e = 0, f = b && b.match (E); se (f && 1 === a.nodeType) enquanto (c = f [e ++]) d = n.propFix [c] || c, n.expr.match.bool.test (c) && (a [d] =! 1), a.removeAttribute (c)}, attrHooks: {type: {set: function (a, b) {if (! k.radioValue && "radio" === b && n.nodeName (a, "input")) {var c = a.value; retornar a.setAttribute ("type", b), c && (a.value = c), b}}}}}), Zb = {set: function (a, b, c) {return b ===! 1? n.removeAttr (a, c): a.setAttribute (c, c), c}}, n.each (n.expr.match.bool.source.match (/ \ w + / g), função (a, b) {var c = $ b [b] || n.find.attr; $ b [b] = função (a, b, d) {var e, f; return d || (f = $ b [b], $ b [b] = e, e = nulo ! = c (a, b, d)? b.toLowerCase (): null, $ b [b] = f), e}}); var _b = / ^ (?: input | select | textarea | button) $ /i.n.fn.extend({prop:function(a,b){return J (this, n.prop, a, b, arguments.length> 1)}, removeProp: função (a) {retorna isso.cada (function () {delete this [n.propFix [a] || a]})}}), n.extend ({propFix: {"for": "htmlFor", "class": "className"}, prop: function (a, b, c) {var d, e, f, g = a.nodeType; if (a && 3! == g && 8! == g && 2! == g) retorna f = 1! == g || ! n.isXMLDoc (a), f && (b = n.propFix [b] || b, e = n.propHooks [b]), void 0! == c? e && "set" em e && void 0! == ( d = e.set (a, c, b))? d: a [b] = c: e && "get" em e && null! == (d = e.get (a, b))? d: a [b ]}, propHooks: {tabIndex: {get: function (a) {return a.hasAttribute ("tabindex") || _b.test (a.nodeName) || a.href? a.tabIndex: -1}}} }, k.optSelected || (n.propHooks.selected = {get: function (a) {var b = a.parentNode; return b && b.parentNode && b.parentNode.selectedIndex, null}}), n.each ([" tabIndex "htmlFor "," class ":" className "}, prop: function (a, b, c) {var d, e, f, g = a.nodeType; if (a && 3! == g && 8! == g && 2! == g) retorna f = 1! == g ||! n.isXMLDoc (a), f && (b = n.propFix [b] || b, e = n.propHooks [b]), void 0! == c ? e && "set" em e && void 0! == (d = e.set (a, c, b))? d: a [b] = c: e && "get" em e && null! == (d = e.get (a, b))? d: a [b]}, propHooks: {tabIndex: {get: function (a) {return a.hasAttribute ("tabindex") || _b.test (a.nodeName) || a .href? a.tabIndex: -1}}}}), k.optSeleccionado || (n.propHooks.selected = {get: function (a) {var b = a.parentNode; return b && b.parentNode && b.parentNode.selectedIndex , null}}), n.each (["tabIndex"htmlFor "," class ":" className "}, prop: function (a, b, c) {var d, e, f, g = a.nodeType; if (a && 3! == g && 8! == g && 2! == g) retorna f = 1! == g ||! n.isXMLDoc (a), f && (b = n.propFix [b] || b, e = n.propHooks [b]), void 0! == c ? e && "set" em e && void 0! == (d = e.set (a, c, b))? d: a [b] = c: e && "get" em e && null! == (d = e.get (a, b))? d: a [b]}, propHooks: {tabIndex: {get: function (a) {return a.hasAttribute ("tabindex") || _b.test (a.nodeName) || a .href? a.tabIndex: -1}}}}), k.optSeleccionado || (n.propHooks.selected = {get: function (a) {var b = a.parentNode; return b && b.parentNode && b.parentNode.selectedIndex , null}}), n.each (["tabIndex"f && (b = n.propFix [b] || b, e = n.propHooks [b]), void 0! == c? e && "set" em e & e void 0! == (d = e.set (a, c, b))? d: a [b] = c: e && "get" em e && null! == (d = e.get (a, b))? d: a [b]}, propHooks: {tabIndex: {get: function (a) {return a.hasAttribute ("tabindex") || _b.test (a.nodeName) || a.href? a.tabIndex: -1}}}}), k.optSeleccionado || (n.propHooks.selected = {get: function (a) {var b = a.parentNode; return b && b.parentNode && b.parentNode.selectedIndex, null}}), n.each (["tabIndex"f && (b = n.propFix [b] || b, e = n.propHooks [b]), void 0! == c? e && "set" em e & e void 0! == (d = e.set (a, c, b))? d: a [b] = c: e && "get" em e && null! == (d = e.get (a, b))? d: a [b]}, propHooks: {tabIndex: {get: function (a) {return a.hasAttribute ("tabindex") || _b.test (a.nodeName) || a.href? a.tabIndex: -1}}}}), k.optSeleccionado || (n.propHooks.selected = {get: function (a) {var b = a.parentNode; return b && b.parentNode && b.parentNode.selectedIndex, null}}), n.each (["tabIndex"propHooks.selected = {get: function (a) {var b = a.parentNode; retornar b && b.parentNode && b.parentNode.selectedIndex, null}}), n.each (["tabIndex"propHooks.selected = {get: function (a) {var b = a.parentNode; retornar b && b.parentNode && b.parentNode.selectedIndex, null}}), n.each (["tabIndex""readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], função () {n.propFix [this.toLowerCase ( )] = this}); var ac = / [\ t \ r \ n \ f] /g.n.fn.extend ({addClass: função (a) {var b, c, d, e, f, g , h = "string" == typeof a && a, i = 0, j = this.length; if (n.isFunction (a)) return this.each (function (b) {n (this) .addClass (a.call (isto é, b, this.className))}); se (h) for (b = (a || ""). combine (E) || []; j> i; i ++) if (c = this [ i], d = 1 === c.nodeType && (c.className? ("" + c.className + "") .replace (ac, ""): "")) {f = 0; while (e = b [f ++]) d.indexOf ("" + e + "") <0 && (d + = e + ""); g = n.trim (d), c.className! == g && (c.className = g)} return this}, removeClass:função (a) {var b, c, d, e, f, g, h = 0 === arguments.length || "string" == typeof a && a, i = 0, j = this.length; if (n .isFunction (a)) return this.each (function (b) {n (this) .removeClass (a.call (this, b, this.className))}); se (h) for (b = (a | "(") "" "" "" "" "" "" "" "" "" "'' '' '' '' '' '' '' '' '' '' '' '' '' ")) .replace (ac," "):" ")) {f = 0; while (e = b [f ++]) enquanto (d.indexOf (" "+ e +" ")> = 0) d = d .replace ("" + e + "", ""); g = a? n.trim (d): "", c.className! == g && (c.className = g)} retorna esta}, toggleClass: função (a, b) {var c = typeof a; return "boolean" == typeof b && "string" === c? b? this.addClass (a): this.removeClass (a): this.each (n. isFunction (a)? function (c) {n (this) .toggleClass (a.call (this, c, this.className, b), b)}:function () {if ("string" === c) {var b, d = 0, e = n (este), f = a.match (E) || []; while (b = f [d ++] ) e.hasClass (b)? e.removeClass (b): e.addClass (b)} else (c === U || "boolean" === c) && (this.className && L.set (isto, " __className __ ", this.className), this.className = this.className || a ===! 1?" ": L.get (this," __ className __ ") ||" ")})}, hasClass: função ( a) {for (var b = "" + a + "", c = 0, d = this.length; d> c; c ++) se (1 === este [c] .nodeType && ("" + this [c ] .className + "") .replace (ac, "") .indexOf (b)> = 0) return! 0; return! 1}}); var bc = / \ r / g; n.fn.extend ({ val: function (a) {var b, c, d, e = this [0]; {if (arguments.length) retorna d = n.isFunction (a), this.each (function (c) {var e; 1 === this.nodeType && (e = d? A.call (isto, c, n (este) .val ()): a, null == e? E = "": "número"== typeof e? e + = "": n.isArray (e) && (e = n.map (e, function (a) {return null == a? "": a + ""})), b = n .valHooks [this.type] || n.valHooks [this.nodeName.toLowerCase ()], b && "set" em b & e void 0! == b.set (this, e, "value") || (this.value = e))}); se (e) retornar b = n.valHooks [e.type] || n.valHooks [e.nodeName.toLowerCase ()], b && "get" em b && void 0! == (c = b.get (e, "valor"))? c: (c = e.value, "string" == typeof c? c.replace (bc, ""): null == c? "": c)} }}), n.extend ({valHooks: {option: {get: function (a) {var b = n.find.attr (a, "value"); return null! = b? b: n.trim ( n.text (a))}}, selecione: {get: function (a) {for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a .type || 0> e, g = f? null: [], h = f? e + 1: d.length, i = 0> e? h: f? e: 0; h> i; i ++) se (c = d [i],! (! c.selected && i! == e || (k.optDisabled? c.disabled: null! == c.getAttribute ("desativado")) || c.parentNode.disabled && n.nodeName (c.parentNode, "optgroup"))) {if (b = n (c) .val () f) return b; g.push (b)} return g}, set: function (a, b) {var c, d, e = a.options, f = n.makeArray (b), g = e.length; while (g -) d = e [g], (d.selected = n.inArray (d.value, f)> = 0) && (c =! 0); return c || (a .selectedIndex = -1), f}}}}), n.each (["rádio", "caixa de seleção"], função () {n.valHooks [this] = {set: function (a, b) {return n.isArray (b)? a.checked = n.inArray (n (a) .val (), b)> = 0: void 0}}, k.checkOn || (n.valHooks [this] .get = função (a) {return null === a.getAttribute ("value")? "em": a.value})}), n.each ("borrão foco foco foco recurso redimensionar rolar descarregar clique dblclick mousedown mouseup mousemove mouseover mouseout mouse mouseleave alterar selecionar enviar keydown keypress keyup error contextmenu ".split (" "), função (a, b) {n.fn [b] = função (a , c) {return arguments.length> 0? this.on (b, null, a, c): this.trigger (b)}}), n.fn.extend ({hover: function (a, b) { retornar this.mouseenter (a) .mouseleave (b || a)}, bind: function (a, b, c) {return this.on (a, null, b, c)}, unbind: function (a, b ) {return this.off (a, null, b)}, delegate: function (a, b, c, d) {return this.on (b, a, c, d)}, undelegate: function (a, b , c) {return 1 === arguments.length? this.off (a, "**"): this.off (b, a || "**", c)}}); var cc = n. agora (), dc = / \? /; n.parseJSON = função (a) {return JSON.parse (a + "")}, n.parseXML = função (a) {var b, c; if (! a | | "string"! = typeof a) return null; tente {c = new DOMParser, b = c.ParseFromString (a, "text / xml")} catch (d) {b = void 0} return (! b || b.getElementsByTagName ("parsererror"). length) && n.error ("XML inválido:" + a) , b}; var ec, fc, gc = / #. * $ /, hc = / ([? &]) _ = [^ &] * /, ic = / ^ (. *?): [\ t] * ([^ \ r \ n] *) $ / gm, jc = / ^ (?: sobre | app | app-storage |. + - extensão | arquivo | res | widget): $ /, kc = / ^ ( ?: GET | HEAD) $ /, lc = / ^ \ / \ //, mc = / ^ ([\ w. + -] +:) (?: \ / \ / (?: [^ \ /? # ] * @ |) ([^ \ /? #:] *) (? :: (\ d +) |) |) /, nc = {}, oc = {}, pc = "* /". concat (" * "); tente {fc = location.href} catch (qc) {fc = l.createElement (" a "), fc.href =" ", fc = fc.href} ec = mc.exec (fc.toLowerCase) () = função de retorno (b, c) {"string"! = typeof b && (c = b, b = "*"); var d, e = 0, f = b.toLowerCase (). match (E) || []; if (n.isFunction (c)) while (d = f [e ++]) "+" === d [0]? (d = d.slice (1) || "*", (a [d] = a [d] || []). Unshift (c)) :( a [d] = a [d] || []).push (c)}} função sc (a, b, c, d) {var e = {}, f = a === oc; função g (h) {var i; return e [h] =! 0, n.each (a [h] || [], função (a, h) {var j = h (b, c, d); retorna "string"! = typeof j || f || e [j]? f?! (i = j): void 0: (b.dataTypes.unshift (j), g (j) ,! 1)}), i} retornar g (b.dataTypes [0]) ||! e [ "*"] && g ("*")} função tc (a, b) {var c, d, e = n.ajaxSettings.flatOptions || {}; para (c em b) void 0! == b [c ] && ((e [c]? a: d || (d = {})) [c] = b [c]); return d && n.extend (! 0, a, d), a} função uc (a , b, c) {var d, e, f, g, h = a.contents, i = a.dataTypes; while ("*" === i [0]) i.shift (), void 0 == = d && (d = a.mimeType || b.getResponseHeader ("Content-Type")); se (d) para (e em h) se (h [e] && h [e] .test (d)) {i .unshift (e); break} if (i [0] em c) f = i [0]; else {for (e in c) {if (! i [0] || a.converters [e + "" + i [0]]) {f = e; break} g || (g = e)} f = f || g} return f? (f! == i [0] && i.unshift (f), c [ f]):void 0} função vc (a, b, c, d) {var e, f, g, h, i, j = {}, k = a.dataTypes.slice (); se (k [1]) para ( g em a.converters) j [g.toLowerCase ()] = a.converters [g]; f = k.shift (); while (f) if (a.responseFields [f] && (c [a.responseFields [ f]] = b), i && d && a.dataFilter && (b = a.dataFilter (b, a.dataType)), i = f, f = k.shift ()) se ("*" === f) f = i; else if ("*"! == i && i! == f) {if (g = j [i + "" + f] || j ["*" + f] ,! g) para (e em j) se (h = e.split (""), h [1] === f && (g = j [i + "" + h [0]] || j ["*" + h [0]])) { g ===! 0? g = j [e]: j [e]! ==! 0 && (f = h [0], k.unshift (h [1])); break} if (g! == !) Se (g && a ["joga"]) b = g (b); então tente {b = g (b)} catch (l) {return {state: "parsererror", erro: g? L: "No conversão de "+ i +" para "+ f}}} return {state:" success ", data: b}} n.extend ({ativo: 0, lastModified: {}, etag: {},ajaxSettings: {url: fc, digite: "GET", isLocal: jc.test (ec [1]), global:! 0, processData:! 0, async:! 0, contentType: "application / x-www-form "text / html", xml: "application / xml, text / xml", json: " application / json, text / javascript "}, conteúdo: {xml: / xml /, html: / html /, json: / json /}, responseFields: {xml:" responseXML ", texto:" responseText ", json:" responseJSON "}, conversores: {" * text ": String," text html ":! 0," text json ": n.parseJSON," text xml ": n.parseXML}, flatOptions: {url:! 0, context :! 0}}, ajaxSetup: function (a, b) {return b? Tc (tc (a, n.ajaxSettings), b): tc (n.ajaxSettings, a)}, ajaxPrefilter: rc (nc), ajaxTransport : rc (oc), ajax: function (a, b) {"object" == typeof a && (b = a, a = void 0),b = b || {}; var c, d, e, f, g, h, i, j, k = n.ajaxSetup ({}, b), l = k.context || k, m = k. context && (l.nodeType || l.jquery)? n (l): n.event, o = n.Deferred (), p = n.Callbacks ("uma vez que a memória"), q = k.statusCode || {} r = {}, s = {}, t = 0, u = "cancelado", v = {readyState: 0, getResponseHeader: função (a) {var b; if (2 === t) {if (! f) {f = {}; enquanto (b = ic.exec (e)) f [b [1] .toLowerCase ()] = b [2]} b = f [a.toLowerCase ()]} return null = = b? null: b}, getAllResponseHeaders: function () {return 2 === t? e: null}, setRequestHeader: função (a, b) {var c = a.toLowerCase (); return t || (a = s [c] = s [c] || a, r [a] = b), this}, overrideMimeType: function (a) {return t || (k.mimeType = a), this}, statusCode: função (a) se (2> t) para (b em a) q [b] = [q [b], a [b]]; else v.always (a [v.status ]); return this}, abortar: function (a) {var b = a || u; retornar c && c.abort (b), x (0, b), this}}; if (o.promise (v). complete = p.add, v.success = v.done, v.error = v.fail, k.url = ((a || k.url || fc) + ""). substituir (gc, ""). substituir (lc, ec [1] + "//"), k.type = b.method | | b.type || k.method || k.type, k.dataTypes = n.trim (k.dataType || "*"). toLowerCase (). match (E) || [""], null = = k.crossDomain && (h = mc.exec (k.url.toLowerCase ()), k.crossDomain =! (! h || h [1] === ec [1] && h [2] === ec [ 2] && (h [3] || ("http:" === h [1]? "80": "443")) === (ec [3] || ("http:" === ec [1]? "80": "443")))), k.data && k.processData && "string"! = typeof k.data && (k.data = n.param (k.data, k.traditional)), sc (nc, k, b, v), 2 === t) return v; i = k.global, i && 0 === n.active ++ && n.event.trigger ("ajaxStart"), k.type = k.type.toUpperCase (), k.hasContent =! kc.test (k.type), d = k.url, k.hasContent || (k.data && (d = k.url + = (dc.test (d )? "&": "?) + k.data, delete k.data), k.cache ===! 1 && (k.url = hc.test (d)? d.replace (hc, "$ 1 _ =" + cc ++): d + (dc.test ")" e ":"? ") +" _ = "+ cc ++)), k.ifModified && (n.lastModified [d] && v.setRequestHeader (" If-Modified-Since ", n. lastModified [d]), n.etag [d] && v.setRequestHeader ("If-None-Match", n.etag [d])), (k.data && k.hasContent && k.contentType! ==! 1 || b. contentType) && v.setRequestHeader ("Content-Type", k.contentType), v.setRequestHeader ("Aceitar", k.dataTypes [0] && k.accepts [k.dataTypes [0]]? k.accepts [k.dataTypes [0]] + ("*"! == k.dataTypes [0]? "," + Pc + "; q = 0.01": ""): k.accepts ["*"]); para (j in k .headers) v.setRequestHeader (j, k.headers [j]); se (k.beforeSend && (k.beforeSend.call (l, v, k) ===!1 || 2 === t)) return v.abort (); u = "abortar"; para (j em {sucesso: 1, erro: 1, concluir: 1}) v [j] (k [j] ), se (c = sc (oc, k, b, v)) {v.readyState = 1, i && m.trigger ("ajaxSend", [v, k]), k.async && k.timeout> 0 && (g = setTimeout (função {) {v.abort ("timeout")}, k.timeout)); tente {t = 1, c.send (r, x)} catch (w) {if (! (2> t)) throw w; x (-1, w)}} else x (-1, "Sem Transporte"); função x (a, b, f, h) {var j, r, s, u, w, x = b ; 2! == t && (t = 2, g && clearTimeout (g), c = void 0, e = h || "", v.readyState = a> 0? 4: 0, j = a> = 200 && 300> a | | 304 === a, f && (u = uc (k, v, f)), u = vc (k, u, v, j), j? (K.ifModified && (w = v.getResponseHeader ("Last- Modificado "), w && (n.lastModified [d] = w), w = v.getResponseHeader (" etag "), w && (n.etag [d] = w)), 204 === a ||" HEAD " === k.type? x = "nocontent": 304 === a? x = "não é modificado ":( x = u.state, r = u.data, s = u.error, j =! s)) :( s = x, (a ||! x) && (x =" error ", 0 > a && (a = 0))), v.status = a, v.statusText = (b || x) + "", j? o.resolveWith (l, [r, x, v]): o.rejectWith (l, [v, x, s]), v.statusCode (q), q = void 0, i && m.trigger (j? "ajaxSuccess": "ajaxError", [v, k, j? r: s]) , p.fireWith (l, [v, x]), i && (m.trigger ("ajaxComplete", [v, k]), - n.active || n.event.trigger ("ajaxStop"))) } return v}, getJSON: função (a, b, c) {return n.get (a, b, c, "json")}, getScript: função (a, b) {return n.get (a, void 0, b, "script")}}), n.each (["get", "post"], função (a, b) {n [b] = função (a, c, d, e) {return n.isFunction (c) && (e = e || d, d = c, c = void 0), n.ajax ({url: a, tipo: b, dataType: e, dados: c, sucesso: d} )}}), n.each (["ajaxStart", "ajaxStop", "ajaxComplete","ajaxError", "ajaxSuccess", "ajaxSend"], função (a, b) {n.fn [b] = função (a) {return this.on (b, a)}}), n._evalUrl = função (a) {return n.ajax ({url: a, digite: "GET", dataType: "script", async:! 1, global:! 1, "throws":! 0})}, n.fn. ({wrapAll: function (a) {var b; return n.isFunction (a)? this.each (função (b) {n (this) .wrapAll (a.call (this, b))}) :( [0] && (b = n (a, this [0] .ownerDocument) .eq (0) .clone (! 0), this [0] .parentNode && b.insertBefore (this [0]), b.map ( função () {var a = this; while (a.firstElementChild) a = a.firstElementChild; return a}). append (this)), this)}, wrapInner: function (a) {return this.each (n. isFunction (a)? function (b) {n (this) .wrapInner (a.call (this, b))}: function () {var b = n (this), c = b.contents (); c. comprimento? c.wrapAll (a): b.append (a)})}, wrap: function (a) {var b = n.isFunction (a); retorna this.each (função (c) {n (this) .wrapAll (b? a.call (this, c): a)})}, unwrap: function () {return this.parent (). each (function () {n.nodeName (this, "body") || n (este) .replaceWith (this.childNodes)}). end ()}}), n.expr.filters.hidden = function (a) {return a.offsetWidth <= 0 && a.offsetHeight <= 0}, n. expr.filters.visible = função (a) {return! n.expr.filters.hidden (a)}; var wc = /% 20 / g, xc = / \ [\] $ /, yc = / \ r? \ n / g, zc = / ^ (?: enviar | botão | imagem | redefinir | arquivo) $ / i, Ac = / ^ (?: entrada | selecionar | textarea | keygen) / i; função Bc (a, b c) d) {var e; if (n.isArray (b)) n.each (b, function (b, e) {c || xc.test (a)? d (a, e): Bc ( a + "[" + ("object" == typeof e? b: "") + "]", e, c, d)}); else if (c || "object"! == n.type (b )) d (a, b); mais para (e em b) Bc (a + "[" + e + "]", b [e], c, d)} n.param = função (a, b) {var c, d = [], e = função (a, b) {b = n.isFunction (b)? b (): null == b? "": b, d [d.length] = encodeURIComponent (a) + "=" + encodeURIComponent (b)}; if (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional), n.isArray (a) || a.jquery &&! n.isPlainObject (a)) n.each (a, function () {e (this.name, this.value)}); else for (c in a) Bc (c, a [c], b, e) ; return d.join ("&"). replace (wc, "+")}, n.fn.extend ({serialize: function () {return n.param (this.serializeArray ())}, serializeArray: função () {return this.map (function () {var a = n.prop (this, "elements"); return a? n.makeArray (a): this}). filter (function () {var a = this .type; return this.name &&! n (this) .is (": disabled") && Ac.test (this.nodeName) &&! zc.test (a) && (this.checked ||! T.test (a) )}). map (função (a, b) {var c = n (este) .val (); return null == c? null: n.isArray (c)? n.map (c, função (a) {return {name: b.name, value: a.replace (yc, "\ r \ n ")}}): {name: b.name, value: c.replace (yc," \ r \ n ")}}). get ()}}), n.ajaxSettings.xhr = função () {try {return new XMLHttpRequest} catch (a) {}}; var Cc = 0, Dc = {}, Ec = {0: 200,1223: 204}, Fc = n.ajaxSettings.xhr (); a .ActiveXObject && n (a) .on ("descarregar", function () {for (var a in Dc) Dc [a] ()}), k.cors = !! Fc && "withCredentials" em Fc, k.ajax = Fc = !! Fc, n.ajaxTransport (função (a) {var b; return k.cors || Fc &&! A.crossDomain? {Send: function (c, d) {var e, f = a.xhr (), g = ++ Cc; if (f.open (a.type, a.url, a.async, a.username, a.password), a.xhrFields) para (e em a.xhrFields) f [e] = a.xhrFields [e]; a.mimeType && f.overrideMimeType && f.overrideMimeType (a.mimeType), a.crossDomain || c ["X-Requested-With"] || (c ["X-Requested-With"] = " XMLHttpRequest "); para (e em c) f.setRequestHeader (e, c [e]); b = função (a) {função de retorno () {b && (apagar Dc [g], b = f.onload = f.onerror = null, "abortar" === a? f.abort (): "error" === a? d (f.status, f. statusText): d (Ec [f.status] || f.status, f.statusText, "string" == typeof f.responseText? {text: f.responseText}: void 0, f.getAllResponseHeaders ()))} } f.onload = b (), f.onerror = b ("erro"), b = Dc [g] = b ("abortar"); tente {f.send (a.hasContent && a.data || null) } catch (h) {if (b) throw h}}, abortar: function () {b && b ()}}: void 0}), n.ajaxSetup ({aceita: {script: "text / javascript, application / javascript , application / ecmascript, application / x-ecmascript "}, conteúdo: {script: / (?: java | ecma) script /}, conversores: {" script de texto ": function (a) {return n.globalEval (a) , a}}}), n.ajaxPrefilter ("script", função (a) {void 0 === a.cache && (a.cache =! 1), a.crossDomain && (a.type = "GET")} ), n.ajaxTransport ("script ", função (a) {if (a.crossDomain) {var b, c; return {send: function (d, e) {b = n (" <script> "). prop ({async:! 0, charset: a.scriptCharset, src: a.url}). on ("load error", c = function (a) {b.remove (), c = null, a && e ("erro" === a.type? 404: 200, a.type)}), l.head.appendChild (b [0])}, abortar: function () {c && c ()}}}}); var Gc = [], Hc = / (= ) \? (? = & | $) | \? \? /; n.ajaxSetup ({jsonp: "callback", jsonpCallback: function () {var a = Gc.pop () || n.expando + "_" + cc ++; retorna este [a] =! 0, a}}), n.ajaxPrefilter ("json jsonp", função (b, c, d) {var e, f, g, h = b.jsonp! == ! 1 && (Hc.test (b.url)? "Url": "string" == typeof b.data &&! (B.contentType || ""). IndexOf ("application / x-www-form-urlencoded") && Hc.test (b.data) && "dados"); retorno h || "jsonp" === b.dataTypes [0]? (e = b.jsonpCallback = n.isFunction (b.jsonpCallback)? b.jsonpCallback (): b.jsonpCallback, h? b [h] = b [h] .replace (Hc, "$ 1") + e): b.jsonp! ==! 1 && (b.url + = (dc.test (b.url)? "e": "?") + b.jsonp + "=" + e), b.converters [ "script json"] = function () {return g || n.error (e + "não foi chamado"), g [0]}, b.dataTypes [0] = "json", f = a [e], a [e] = function () {g = arguments}, d.always (function () {a [e] = f, b [e] && (b.jsonpCallback = c.jsonpCallback, Gc.push (e)) g && n.isFunction (f) && f (g [0]), g = f = void 0}), "script"): void 0}), n.parseHTML = função (a, b, c) {if (! um || "string"! = typeof a) return null; "boolean" == typeof b && (c = b, b =! 1), b = b || l; var d = v.exec (a), e =! c && []; return d? [b.createElement (d [1])] :( d = n.buildFragment ([a], b, e), e && e.length && n (e) .remove (), n.mesclar ([], d.childNodes)); var Ic = n.fn.load; n.fn.load = function (a, b, c) {if ("string"! = typeof a && Ic) retornar Ic.apply (isto, argumentos); var d, e, f, g = isto, h = a.indexOf (""); return h> = 0 && (d = n.trim (a.slice (h)), a = a .slice (0, h)), n.isFunction (b)? (c = b, b = void 0): b && "object" == typeof b && (e = "POST"), g.length> 0 && n.ajax ({url: a, tipo: e, dataType: "html", dados: b}). done (função (a) {f = argumentos, g.html (d? n ("<div>"). anexar ( n.parseHTML (a)). find (d): a)}). complete (c && function (a, b) {g.each (c, f || [a.responseText, b, a])}), isto }, n.expr.filters.animated = function (a) {return n.grep (n.timers, function (b) {return a === b.elem}). length}; var Jc = a.document. documentElement; função Kc (a) {return n.isWindow (a)? a: 9 === a.nodeType && a.defaultView} nkffset = {setOffset: função (a, b, c) {var d, e,f, g, h, i, j, k = n.css (a, "posição"), l = n (a), m = {}; "estático" === k && (a.style.position = " relativo "), h = l.offset (), f = n.css (a," top "), i = n.css (a," left "), j = (" absolute "=== k || "fixed" === k) && (f + i) .indexOf ("auto")> - 1, j? (d = l.position (), g = d.top, e = d.left) :( g = parseFloat (f) || 0, e = parseFloat (i) || 0), n.isFunction (b) && (b = b.call (a, c, h)), null! = b.top && ( m.top = b.top-h.top + g), null! = b.left && (m.left = b.left-h.left + e), "usando" em b? b.using.call (a m): l.css (m)}}, n.fn.extend ({offset: function (a) {if (arguments.length) retorna void 0 === a? this: this.each (function (b ) {ndset.setOffset (this, a, b)}); var b, c, d = this [0], e = {top: 0, left: 0}, f = d && d.ownerDocument; if (f ) return b = f.documentElement, n.contains (b, d)? (typeof d.getBoundingClientRect! == U && (e = d.getBoundingClientRect ()), c = Kc (f), {top: e.top + c.pageYOffset-b.clientTop, esquerda: e.left + c.pageXOffset-b.clientLeft}): e}, posição: função ( ) {if (this [0]) {var a, b, c = this [0], d = {top: 0, left: 0}; return "fixed" === n.css (c, "position") )? b = c.getBoundingClientRect () :( a = this.offsetParent (), b = this.offset (), n.nodeName (a [0], "html") || (d = a.offset () ), d.top + = n.css (a [0], "borderTopWidth",! 0), d.left + = n.css (a [0], "borderLeftWidth",! 0)), {top: b. top-d.top-n.css (c, "marginTop",! 0), esquerda: b.left-d.left-n.css (c, "marginLeft",! 0)}}}, offsetParent: função () {return this.map (function () {var a = this.offsetParent || Jc; while (a &&! n.nodeName (a, "html") && "static" === n.css (a, " posição ")) a = a.offsetParent; return a || Jc})}}), n.each ({scrollLeft:" pageXOffset ", scrollTop:"pageYOffset "}, função (b, c) {var d =" pageYOffset "=== c; n.fn [b] = função (e) {return J (esta, função (b, e, f) {var g = Kc (b); return void 0 === f? G? G [c]: b [e]: void (g? G.scrollTo (d? A.pageXOffset: f, d? F: a.pageYOffset) : b [e] = f)}, b, e, arguments.length, null)}}), n.each (["top", "left"], função (a, b) {n.cssHooks [b ] = yb (k.pixelPosition, function (a, c) {return c? (c = xb (a, b), vb.test (c)? n (a) .position () [b] + "px" : c): void 0})}), n.each ({Altura: "altura", Largura: "largura"}, função (a, b) {n.each ({preenchimento: "interior" + a, conteúdo : b, "": "externo" + a}, função (c, d) {n.fn [d] = função (d, e) {var f = arguments.length && (c || "boolean"! = typeof d) g = c || (d ===! 0 || e ===! 0? "margem": "borda"); retorno J (isto, função (b, c, d) {var e; retornar n.isWindow (b)? b.document.documentElement ["client" + a]:9 === b.nodeType? (E = b.documentElement, Math.max (b.body ["scroll" + a], e ["scroll" + a], b.body ["offset" + a], e ["offset" + a], e ["cliente" + a])): void 0 === d? n.css (b, c, g): n.style (b, c, d, g) }, b, f? d: void 0, f, null)}})}), n.fn.size = function () {return this.length}, n.fn.andSelf = n.fn.addBack, " função == typeof define && define.amd && define ("jquery", [], function () {return n}); var Lc = a.jQuery, Mc = a. $; return n.noConflict = function (b) {return a . $ === n && (a. $ = Mc), b && a.jQuery === n && (a.jQuery = Lc), n}, typeof b === U && (a.jQuery = a. $ = n), n});size = function () {return this.length}, n.fn.andSelf = n.fn.addBack, "function" == typeof define && define.amd && define ("jquery", [], function () {return n}); var Lc = a.jQuery, Mc = a. $; return n.noConflict = function (b) {return a. $ === n && (a. $ = Mc), b && a.jQuery === n && (a.jQuery = Lc), n}, typeof b === U && (a.jQuery = a. $ = N), n});size = function () {return this.length}, n.fn.andSelf = n.fn.addBack, "function" == typeof define && define.amd && define ("jquery", [], function () {return n}); var Lc = a.jQuery, Mc = a. $; return n.noConflict = function (b) {return a. $ === n && (a. $ = Mc), b && a.jQuery === n && (a.jQuery = Lc), n}, typeof b === U && (a.jQuery = a. $ = N), n});